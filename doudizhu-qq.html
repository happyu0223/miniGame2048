<html lang="zh-CN"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ–—åœ°ä¸»æ¸¸æˆ - å…¨æ–°ç‰ˆæœ¬</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#0066cc',
                        secondary: '#004499',
                        accent: '#ff6b00',
                        dark: '#0a192f',
                        light: '#f8f9fa'
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif']
                    },
                    animation: {
                        'card-fly': 'cardFly 0.3s ease-out',
                        'card-shake': 'cardShake 0.3s ease-in-out',
                        'pulse-fast': 'pulse 1s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                        'glow': 'glow 2s ease-in-out infinite alternate'
                    },
                    keyframes: {
                        cardFly: {
                            '0%': { transform: 'translate(0, 0) scale(1)', opacity: 1 },
                            '100%': { transform: 'translate(var(--x), var(--y)) scale(0.8)', opacity: 1 }
                        },
                        cardShake: {
                            '0%, 100%': { transform: 'rotate(-3deg)' },
                            '50%': { transform: 'rotate(3deg)' }
                        },
                        glow: {
                            '0%': { boxShadow: '0 0 5px rgba(255, 215, 0, 0.5)' },
                            '100%': { boxShadow: '0 0 20px rgba(255, 215, 0, 0.8)' }
                        }
                    }
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .glass {
                background: rgba(255, 255, 255, 0.1);
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.2);
            }
            .text-shadow {
                text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            }
            .card-hover {
                transition: all 0.2s ease;
            }
            .card-hover:hover {
                transform: translateY(-10px) scale(1.05);
                z-index: 10;
            }
            .card-selected {
                transform: translateY(-15px) scale(1.1);
                box-shadow: 0 8px 25px rgba(255, 215, 0, 0.8);
                z-index: 20;
            }
            .player-highlight {
                border: 3px solid #ffd700;
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
                animation: glow 1.5s ease-in-out infinite alternate;
            }
            .card-stack {
                position: relative;
                width: 60px;
                height: 84px;
                margin: 0 auto;
            }
            .card-stack .card {
                position: absolute;
                top: 0;
                left: 0;
                transition: all 0.1s ease;
            }
            .card-stack .card:nth-child(1) { transform: translate(0, 0) rotate(0deg); }
            .card-stack .card:nth-child(2) { transform: translate(3px, 3px) rotate(1deg); }
            .card-stack .card:nth-child(3) { transform: translate(6px, 6px) rotate(2deg); }
            .card-stack .card:nth-child(4) { transform: translate(9px, 9px) rotate(3deg); }
            .card-stack .card:nth-child(5) { transform: translate(12px, 12px) rotate(4deg); }
            
            /* å¡ç‰ŒåŸºç¡€æ ·å¼ */
            .card {
                width: 50px;
                height: 70px;
                border-radius: 6px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: bold;
                font-size: 16px;
                position: relative;
                transition: all 0.2s ease;
                user-select: none;
            }
            
            .card-back {
                background: linear-gradient(135deg, #2c3e50, #34495e);
                border: 2px solid #3498db;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            }
            
            .card-back::before {
                content: 'ğŸ‚ ';
                font-size: 24px;
                color: #ecf0f1;
            }
            
            .spades, .clubs {
                background: white;
                color: black;
                border: 2px solid #333;
            }
            
            .hearts, .diamonds {
                background: white;
                color: red;
                border: 2px solid red;
            }
            
            .joker {
                background: linear-gradient(135deg, #ffd700, #ffed4e);
                color: #333;
                border: 2px solid #f39c12;
                font-size: 24px;
            }
            
            .card-value {
                position: absolute;
                top: 2px;
                left: 4px;
                font-size: 10px;
                font-weight: bold;
            }
            
            .card-suit {
                font-size: 20px;
            }
            
            .bottom-card {
                width: 45px;
                height: 63px;
                margin: 0 2px;
            }
            
            /* åŠ¨ç”»æ•ˆæœ */
            @keyframes cardDeal {
                0% {
                    transform: translate(0, 0) scale(1) rotate(0deg);
                    opacity: 1;
                }
                100% {
                    transform: var(--transform-end);
                    opacity: 1;
                }
            }
            
            @keyframes cardShake {
                0%, 100% { transform: rotate(-3deg); }
                50% { transform: rotate(3deg); }
            }
            
            @keyframes glow {
                0% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
                100% { box-shadow: 0 0 25px rgba(255, 215, 0, 0.8); }
            }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-dark to-primary min-h-screen flex flex-col overflow-hidden">
    <!-- æ¸¸æˆæ ‡é¢˜ -->
    <header class="py-4 text-center">
        <h1 class="text-4xl font-bold text-white text-shadow">æ–—åœ°ä¸»æ¸¸æˆ</h1>
        <p class="text-light mt-2">å…¨æ–°ç‰ˆæœ¬ - æµç•…åŠ¨ç”»ä½“éªŒ</p>
    </header>

    <!-- æ¸¸æˆä¸»å®¹å™¨ - é”å®šå¤§å° -->
    <main class="flex-1 flex items-center justify-center p-4">
        <!-- æ¸¸æˆåŒºåŸŸ - æŒ‰ç…§ç”¨æˆ·è¦æ±‚çš„æ–°å¸ƒå±€ -->
        <div class="flex gap-4 w-[1000px] h-[700px]">
            <!-- ä¸»è¦æ¸¸æˆåŒºåŸŸ -->
            <div class="flex-1 flex flex-col">
                <!-- é¡¶éƒ¨ç©å®¶ (ä¸Šå®¶) -->
                <div class="player-area mb-4 p-4 rounded-xl bg-dark/30" id="topPlayer">
                    <div class="player-info text-center mb-2 flex items-center justify-center gap-2">
                        <span class="text-white font-semibold" id="topPlayerName">ä¸Šå®¶</span>
                        <span class="landlord-tag bg-yellow-500 text-black font-bold px-2 py-1 rounded-full text-xs" style="display: none;">åœ°ä¸»</span>
                        <span class="farmer-tag bg-green-500 text-white font-bold px-2 py-1 rounded-full text-xs" style="display: none;">å†œæ°‘</span>
                        <span class="text-yellow-400" id="topPlayerStatus"></span>
                    </div>
                    <div class="player-cards flex justify-center" id="topPlayerCards">
                        <!-- å¡ç‰Œå°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                    </div>
                    <div class="current-cards mt-2 flex justify-center" id="topPlayerCurrentCards">
                        <!-- å½“å‰å‡ºç‰Œ -->
                    </div>
                </div>

                <!-- ä¸­é—´åŒºåŸŸ -->
                <div class="flex-1 flex mb-4">
                    <!-- å·¦ä¾§ç©å®¶ (å·¦å®¶) -->
                    <div class="player-area w-1/4 p-4 rounded-xl bg-dark/30 mr-4" id="leftPlayer">
                        <div class="player-info text-center mb-2 flex items-center justify-center gap-2">
                            <span class="text-white font-semibold" id="leftPlayerName">å·¦å®¶</span>
                            <span class="landlord-tag bg-yellow-500 text-black font-bold px-2 py-1 rounded-full text-xs" style="display: none;">åœ°ä¸»</span>
                            <span class="farmer-tag bg-green-500 text-white font-bold px-2 py-1 rounded-full text-xs" style="display: none;">å†œæ°‘</span>
                            <span class="text-yellow-400" id="leftPlayerStatus"></span>
                        </div>
                        <div class="player-cards flex flex-col items-center" id="leftPlayerCards">
                            <!-- å¡ç‰Œå°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                        </div>
                        <div class="current-cards mt-2 flex flex-col items-center" id="leftPlayerCurrentCards">
                            <!-- å½“å‰å‡ºç‰Œ -->
                        </div>
                    </div>

                    <!-- ä¸­é—´åŒºåŸŸ - æ­£æ–¹å½¢ -->
                    <div class="flex-1 p-4 rounded-xl bg-dark/40 border border-white/10 flex flex-col items-center justify-center" style="width: 250px; height: 250px;">
                        <!-- ç‰Œå åŒºåŸŸ -->
                        <div class="card-stack mb-4" id="cardStack">
                            <div class="card card-back"></div>
                            <div class="card card-back"></div>
                            <div class="card card-back"></div>
                            <div class="card card-back"></div>
                            <div class="card card-back"></div>
                        </div>
                        
                        <!-- åº•ç‰ŒåŒºåŸŸ -->
                        <div class="bottom-cards flex gap-2 mb-4" id="bottomCards">
                            <div class="card card-back bottom-card" id="bottomCard0"></div>
                            <div class="card card-back bottom-card" id="bottomCard1"></div>
                            <div class="card card-back bottom-card" id="bottomCard2"></div>
                        </div>
                        
                        <!-- æ¸¸æˆçŠ¶æ€ -->
                        <div class="game-status text-center">
                            <p class="text-white text-xl font-semibold" id="gameStatus">å‡†å¤‡å¼€å§‹æ¸¸æˆ</p>
                        </div>
                    </div>
                </div>

                <!-- åº•éƒ¨ç©å®¶ (è‡ªå·±) -->
                <div class="player-area p-4 rounded-xl bg-dark/30" id="bottomPlayer">
                    <div class="player-info text-center mb-2 flex items-center justify-center gap-2">
                        <span class="text-white font-semibold" id="bottomPlayerName">æˆ‘</span>
                        <span class="landlord-tag bg-yellow-500 text-black font-bold px-2 py-1 rounded-full text-xs" style="display: none;">åœ°ä¸»</span>
                        <span class="farmer-tag bg-green-500 text-white font-bold px-2 py-1 rounded-full text-xs" style="display: none;">å†œæ°‘</span>
                        <span class="text-yellow-400" id="bottomPlayerStatus"></span>
                    </div>
                    <div class="player-cards flex justify-end flex-wrap gap-1" id="bottomPlayerCards">
                        <!-- å¡ç‰Œå°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                    </div>
                    <div class="current-cards mt-2 flex justify-center" id="bottomPlayerCurrentCards">
                        <!-- å½“å‰å‡ºç‰Œ -->
                    </div>
                    <!-- æ“ä½œæŒ‰é’® -->
                    <div class="action-buttons flex justify-center mt-4 gap-4" id="actionButtons">
                        <button id="startGameBtn" class="bg-accent hover:bg-orange-600 text-white px-6 py-3 rounded-lg font-bold transition-all duration-300 transform hover:scale-105 shadow-lg">
                            å¼€å§‹æ¸¸æˆ
                        </button>
                    </div>
                </div>
            </div>

            <!-- ä¿¡æ¯é¢æ¿ - æ”¾åœ¨å³ä¾§ -->
            <div class="w-64 bg-dark/50 rounded-2xl p-4 glass flex-shrink-0">
                <h3 class="text-xl font-bold text-white mb-4">æ¸¸æˆä¿¡æ¯</h3>
                
                <!-- ç©å®¶ä¿¡æ¯ -->
                <div class="mb-6">
                    <h4 class="text-lg font-semibold text-light mb-2">ç©å®¶</h4>
                    <div class="space-y-2">
                        <div class="flex items-center justify-between">
                            <span class="text-white">æˆ‘</span>
                            <span class="text-yellow-400" id="humanCardsCount">0å¼ </span>
                        </div>
                        <div class="flex items-center justify-between">
                            <span class="text-white">å·¦å®¶</span>
                            <span class="text-yellow-400" id="leftCardsCount">0å¼ </span>
                        </div>
                        <div class="flex items-center justify-between">
                            <span class="text-white">ä¸Šå®¶</span>
                            <span class="text-yellow-400" id="topCardsCount">0å¼ </span>
                        </div>
                    </div>
                    
                    <!-- AIæ‰˜ç®¡æŒ‰é’® -->
                    <div class="mt-4">
                        <button id="aiModeBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded-lg text-sm font-semibold transition-all duration-300">
                            AIæ‰˜ç®¡: å…³é—­
                        </button>
                    </div>
                </div>
                
                <!-- æ¸¸æˆç»Ÿè®¡ -->
                <div>
                    <h4 class="text-lg font-semibold text-light mb-2">ç»Ÿè®¡</h4>
                    <div class="space-y-2 text-sm">
                        <div class="flex justify-between">
                            <span class="text-white">æ€»å±€æ•°</span>
                            <span class="text-yellow-400" id="totalGames">0</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-white">è·èƒœæ¬¡æ•°</span>
                            <span class="text-yellow-400" id="wins">0</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-white">èƒœç‡</span>
                            <span class="text-yellow-400" id="winRate">0%</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script>
        // æ¸¸æˆç±»
        class DoudizhuGame {
            constructor() {
                this.players = ['left', 'top', 'bottom']; // ç©å®¶é¡ºåºï¼šå·¦å®¶ -> ä¸Šå®¶ -> è‡ªå·±
                this.playerNames = {
                    left: 'å·¦å®¶',
                    top: 'ä¸Šå®¶',
                    bottom: 'æˆ‘'
                };
                
                // æ¸¸æˆæ•°æ®
                this.deck = []; // ç‰Œå †
                this.playerCards = { left: [], top: [], bottom: [] }; // ç©å®¶æ‰‹ç‰Œ
                this.bottomCards = []; // åº•ç‰Œ
                this.currentCards = null; // å½“å‰å‡ºç‰Œ
                this.currentCardsPlayer = null; // å½“å‰å‡ºç‰Œç©å®¶
                this.selectedCards = []; // é€‰ä¸­çš„ç‰Œ
                this.landlord = null; // åœ°ä¸»
                this.turnIndex = 0; // å›åˆç´¢å¼•
                this.currentPlayer = null; // å½“å‰ç©å®¶
                this.passCount = 0; // è·³è¿‡æ¬¡æ•°
                this.gamePhase = 'ready'; // æ¸¸æˆé˜¶æ®µï¼šready, dealing, calling, playing, ended
                this.aiMode = false; // AIæ‰˜ç®¡æ¨¡å¼æ ‡å¿—
                
                // æ¸¸æˆç»Ÿè®¡
                this.gameStats = {
                    totalGames: 0,
                    wins: 0,
                    gameTime: 0,
                    gameStartTime: null,
                    currentGameTime: 0,
                    
                    timer: null
                };
                
                // å¡ç‰Œé…ç½®
                this.cardWidth = 50;
                this.cardHeight = 70;
                
                // åˆå§‹åŒ–
                this.initElements();
                this.bindEvents();
                this.initGame();
            }
            
            // åˆå§‹åŒ–DOMå…ƒç´ 
            initElements() {
                this.elements = {
                    // ç©å®¶åŒºåŸŸ
                    players: {
                        left: document.getElementById('leftPlayer'),
                        top: document.getElementById('topPlayer'),
                        bottom: document.getElementById('bottomPlayer')
                    },
                    playerCards: {
                        left: document.getElementById('leftPlayerCards'),
                        top: document.getElementById('topPlayerCards'),
                        bottom: document.getElementById('bottomPlayerCards')
                    },
                    playerCurrentCards: {
                        left: document.getElementById('leftPlayerCurrentCards'),
                        top: document.getElementById('topPlayerCurrentCards'),
                        bottom: document.getElementById('bottomPlayerCurrentCards')
                    },
                    playerStatus: {
                        left: document.getElementById('leftPlayerStatus'),
                        top: document.getElementById('topPlayerStatus'),
                        bottom: document.getElementById('bottomPlayerStatus')
                    },
                    
                    // æ¸¸æˆå…ƒç´ 
                    bottomCards: document.getElementById('bottomCards'),
                    cardStack: document.getElementById('cardStack'),
                    gameStatus: document.getElementById('gameStatus'),
                    actionButtons: document.getElementById('actionButtons'),
                    
                    // ç»Ÿè®¡å…ƒç´ 
                    humanCardsCount: document.getElementById('humanCardsCount'),
                    leftCardsCount: document.getElementById('leftCardsCount'),
                    topCardsCount: document.getElementById('topCardsCount'),
                    totalGames: document.getElementById('totalGames'),
                    wins: document.getElementById('wins'),
                    winRate: document.getElementById('winRate'),
                    
                    // AIæ‰˜ç®¡æŒ‰é’®
                    aiModeBtn: document.getElementById('aiModeBtn')
                };
            }
            
            // ç»‘å®šäº‹ä»¶
            bindEvents() {
                // å¼€å§‹æ¸¸æˆæŒ‰é’®
                document.getElementById('startGameBtn').addEventListener('click', () => {
                    this.startGame();
                });
                
                // çª—å£å¤§å°å˜åŒ–æ—¶é‡æ–°å¸ƒå±€
                window.addEventListener('resize', () => {
                    this.updateLayout();
                });
                
                // AIæ‰˜ç®¡æŒ‰é’®
                this.elements.aiModeBtn.addEventListener('click', () => {
                    this.toggleAIMode();
                });
            }
            
            // åˆå§‹åŒ–æ¸¸æˆ
            initGame() {
                this.updatePlayerInfo();
                this.updateStats();
                this.updateLayout();
            }
            
            // å¼€å§‹æ¸¸æˆ
            async startGame() {
                console.log('ğŸ® å¼€å§‹æ–°æ¸¸æˆ');
                
                // é‡ç½®æ¸¸æˆçŠ¶æ€
                this.resetGame();
                
                // æ›´æ–°æ¸¸æˆé˜¶æ®µ
                this.gamePhase = 'starting';
                
                // ç”Ÿæˆç‰Œå †
                this.generateDeck();
                
                // æ´—ç‰Œ
                this.shuffleDeck();
                
                // éšè—åº•ç‰Œ
                this.elements.bottomCards.style.display = 'none';
                
                // æ˜¾ç¤ºç‰Œå 
                this.elements.cardStack.style.display = 'block';
                
                // æ›´æ–°çŠ¶æ€
                this.updateStatus('å‡†å¤‡å‘ç‰Œ...');
                
                // éšæœºé€‰æ‹©èµ·å§‹ç©å®¶
                const startPlayerIndex = Math.floor(Math.random() * 3);
                const startPlayer = this.players[startPlayerIndex];
                this.currentPlayer = startPlayer;
                
                console.log(`ğŸ¯ éšæœºé€‰æ‹©èµ·å§‹ç©å®¶: ${startPlayer} (${this.playerNames[startPlayer]})`);
                this.updateStatus(`ä»${this.playerNames[startPlayer]}å¼€å§‹å‘ç‰Œ`);
                
                // æ¸…ç©ºå¹¶ç¦ç”¨æ“ä½œæŒ‰é’®
                this.elements.actionButtons.innerHTML = '';
                this.elements.actionButtons.style.pointerEvents = 'none';
                
                // ç­‰å¾…ä¸€ä¼šå„¿å†å¼€å§‹å‘ç‰Œ
                await this.sleep(1000);
                
                // å¼€å§‹å‘ç‰Œ
                await this.dealCards();
                
                // å¼€å§‹å«åœ°ä¸»é˜¶æ®µ
                await this.startCallingPhase();
            }
            
            // é‡ç½®æ¸¸æˆ
            resetGame() {
                console.log('ğŸ”„ é‡ç½®æ¸¸æˆçŠ¶æ€');
                
                // æ¸…ç©ºç©å®¶ç‰Œ
                this.players.forEach(player => {
                    this.playerCards[player] = [];
                    this.elements.playerCards[player].innerHTML = '';
                    this.elements.playerCurrentCards[player].innerHTML = '';
                    this.hideStatus(player);
                });
                
                // é‡ç½®æ¸¸æˆæ•°æ®
                this.bottomCards = [];
                this.currentCards = null;
                this.currentCardsPlayer = null;
                this.selectedCards = [];
                this.landlord = null;
                this.turnIndex = 0;
                this.currentPlayer = this.players[0];
                this.passCount = 0;
                this.gamePhase = 'ready';
                
                // éšè—åº•ç‰Œ
                this.elements.bottomCards.style.display = 'none';
                for (let i = 0; i < 3; i++) {
                    const card = document.getElementById(`bottomCard${i}`);
                    card.className = 'card card-back bottom-card';
                }
                
                // æ˜¾ç¤ºç‰Œå 
                this.elements.cardStack.style.display = 'block';
                
                this.updatePreview();
                this.updatePlayerInfo();
            }
            
            // ç”Ÿæˆç‰Œå †
            generateDeck() {
                const suits = ['spades', 'hearts', 'clubs', 'diamonds'];
                const values = ['3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A', '2'];
                
                this.deck = [];
                
                // ç”Ÿæˆæ™®é€šç‰Œ
                suits.forEach(suit => {
                    values.forEach(value => {
                        this.deck.push({ suit, value });
                    });
                });
                
                // æ·»åŠ å¤§å°ç‹
                this.deck.push({ suit: 'joker', value: 'small' });
                this.deck.push({ suit: 'joker', value: 'big' });
                
                console.log('ğŸƒ ç”Ÿæˆç‰Œå †:', this.deck.length, 'å¼ ç‰Œ');
            }
            
            // æ´—ç‰Œ
            shuffleDeck() {
                for (let i = this.deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
                }
                console.log('ğŸ”€ æ´—ç‰Œå®Œæˆ');
            }
            
            // å‘ç‰Œ
            async dealCards() {
                console.log('ğŸ“¤ å¼€å§‹å‘ç‰Œ');
                
                // æ›´æ–°æ¸¸æˆé˜¶æ®µ
                this.gamePhase = 'dealing';
                
                // ä¿ç•™3å¼ åº•ç‰Œ
                this.bottomCards = this.deck.splice(-3);
                console.log('ğŸƒ åº•ç‰Œæ•°é‡:', this.bottomCards.length);
                
                // ç¡®å®šå‘ç‰Œé¡ºåºï¼ˆä»éšæœºé€‰æ‹©çš„ç©å®¶å¼€å§‹ï¼‰
                const startPlayerIndex = this.players.indexOf(this.currentPlayer);
                const playerOrder = [];
                for (let i = 0; i < 3; i++) {
                    playerOrder.push(this.players[(startPlayerIndex + i) % 3]);
                }
                
                console.log('ğŸ“‹ å‘ç‰Œé¡ºåº:', playerOrder.map(p => this.playerNames[p]).join(' â†’ '));
                
                let playerIndex = 0;
                
                // æ¸…ç©ºç©å®¶ç‰Œæ•°ç»„
                this.players.forEach(player => {
                    this.playerCards[player] = [];
                });
                
                // æ˜¾ç¤ºç©ºçš„ç©å®¶ç‰ŒåŒºåŸŸ
                this.elements.playerCards.bottom.innerHTML = '';
                this.elements.playerCards.left.innerHTML = '';
                this.elements.playerCards.top.innerHTML = '';
                
                // é€ä¸ªå‘ç‰Œï¼Œå¸¦åŠ¨ç”»æ•ˆæœï¼ˆå¤šå¼ ç‰ŒåŒæ—¶é£è¡Œï¼‰
                for (let i = 0; i < this.deck.length; i++) {
                    const card = this.deck[i];
                    const player = playerOrder[playerIndex];
                    
                    // æ˜¾ç¤ºå½“å‰ç©å®¶é«˜äº®
                    this.highlightPlayer(player);
                    
                    // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
                    this.updateStatus(`æ­£åœ¨å‘ç‰Œç»™${this.playerNames[player]} (${i + 1}/${this.deck.length})`);
                    
                    // æ˜¾ç¤ºå‘ç‰ŒåŠ¨ç”»å¹¶å®æ—¶æ›´æ–°æ˜¾ç¤ºï¼ˆéé˜»å¡ï¼‰
                    this.showCardDealAnimationWithRealTimeUpdate(card, player);
                    
                    // ç§»é™¤é«˜äº®
                    this.unhighlightPlayer(player);
                    
                    playerIndex = (playerIndex + 1) % 3;
                    
                    // æ›´å°çš„å»¶è¿Ÿï¼Œè®©å¤šå¼ ç‰ŒåŒæ—¶é£è¡Œ
                    await this.sleep(30);
                }
                
                // æ¸…ç©ºç‰Œå †
                this.deck = [];
                
                // æ’åºå¹¶æ˜¾ç¤ºæ‰€æœ‰ç©å®¶çš„ç‰Œï¼ˆåŠ å¼ºç†ç‰Œé€»è¾‘ï¼‰
                console.log('ğŸ”„ å¼€å§‹ç†ç‰Œ...');
                
                // å¼ºåˆ¶æ¸…ç©ºæ˜¾ç¤ºå®¹å™¨ï¼Œç¡®ä¿ç†ç‰Œåé‡æ–°æ¸²æŸ“
                this.elements.playerCards.bottom.innerHTML = '';
                this.elements.playerCards.left.innerHTML = '';
                this.elements.playerCards.top.innerHTML = '';
                
                // ç†ç‰Œ
                this.sortCards();
                
                // éªŒè¯ç†ç‰Œç»“æœ
                const bottomCards = this.playerCards.bottom.map(c => c.value).join(', ');
                console.log(`ğŸ´ ç†ç‰Œåç©å®¶æ‰‹ç‰Œ: ${bottomCards}`);
                
                // å¼ºåˆ¶é‡æ–°æ˜¾ç¤ºæ‰€æœ‰ç©å®¶çš„ç‰Œ
                setTimeout(() => {
                    this.showPlayerCards('bottom');
                    this.showAICards('left');
                    this.showAICards('top');
                }, 100);
                
                console.log('ğŸ“Š å‘ç‰Œå®Œæˆ:');
                this.players.forEach(player => {
                    console.log(`- ${player}: ${this.playerCards[player].length}å¼ `);
                });
                
                // æ˜¾ç¤ºåº•ç‰Œï¼ˆå¸¦é£å‡ºåŠ¨ç”»ï¼‰
                await this.showBottomCardsWithAnimation();
                
                // ç‰Œå æ¶ˆå¤±
                this.elements.cardStack.style.display = 'none';
                
                // å¯ç”¨æ“ä½œæŒ‰é’®
                this.elements.actionButtons.style.pointerEvents = 'auto';
                
                this.updateStatus('å‘ç‰Œå®Œæˆï¼Œå‡†å¤‡å«åœ°ä¸»');
                this.updatePlayerInfo();
            }
            
            // æ˜¾ç¤ºå¡ç‰Œå‘è¡ŒåŠ¨ç”»å¹¶å®æ—¶æ›´æ–°æ˜¾ç¤º
            async showCardDealAnimationWithRealTimeUpdate(card, targetPlayer) {
                try {
                    // åˆ›å»ºä¸´æ—¶å¡ç‰Œå…ƒç´ 
                    const tempCard = document.createElement('div');
                    tempCard.className = 'card card-back';
                    tempCard.style.position = 'fixed';
                    tempCard.style.zIndex = '9999';
                    tempCard.style.pointerEvents = 'none';
                    tempCard.style.boxShadow = '0 6px 20px rgba(0, 0, 0, 0.4)';
                    tempCard.style.width = `${this.cardWidth}px`;
                    tempCard.style.height = `${this.cardHeight}px`;
                    
                    // è·å–ç‰Œå ä½ç½®ï¼ˆåŸºäºè§†å£ï¼‰
                    const cardStackRect = this.elements.cardStack.getBoundingClientRect();
                    const startX = cardStackRect.left + cardStackRect.width / 2 - this.cardWidth / 2;
                    const startY = cardStackRect.top + cardStackRect.height / 2 - this.cardHeight / 2;
                    
                    tempCard.style.left = `${startX}px`;
                    tempCard.style.top = `${startY}px`;
                    
                    // æ·»åŠ åˆ°body
                    document.body.appendChild(tempCard);
                    
                    // è·å–ç›®æ ‡ç©å®¶åŒºåŸŸä½ç½®ï¼ˆåŸºäºè§†å£ï¼‰
                    const targetRect = this.elements.playerCards[targetPlayer].getBoundingClientRect();
                    let targetX, targetY, rotation;
                    
                    switch(targetPlayer) {
                        case 'bottom':
                            // è°ƒæ•´ç©å®¶ç‰Œçš„ç›®æ ‡ä½ç½®ï¼šå±…ä¸­åå³ï¼Œæ›´é ä¸Š
                            targetX = targetRect.left + targetRect.width / 2 - this.cardWidth / 2 + 60;
                            targetY = targetRect.top + 10;
                            rotation = 'rotate(0deg)';
                            break;
                        case 'left':
                            // è°ƒæ•´å·¦å®¶ç‰Œçš„ç›®æ ‡ä½ç½®ï¼šå±…ä¸­ï¼Œæ›´é ä¸‹
                            targetX = targetRect.left + targetRect.width / 2 - this.cardHeight / 2;
                            targetY = targetRect.top + targetRect.height / 2 - this.cardWidth / 2 + 20;
                            rotation = 'rotate(-90deg)';
                            break;
                        case 'top':
                            // è°ƒæ•´ä¸Šå®¶ç‰Œçš„ç›®æ ‡ä½ç½®ï¼šå±…ä¸­ï¼Œæ›´é ä¸‹
                            targetX = targetRect.left + targetRect.width / 2 - this.cardWidth / 2;
                            targetY = targetRect.top + 20;
                            rotation = 'rotate(180deg)';
                            break;
                        default:
                            throw new Error(`æœªçŸ¥çš„ç›®æ ‡ç©å®¶: ${targetPlayer}`);
                    }
                    
                    // è®¾ç½®CSSåŠ¨ç”»
                    tempCard.style.transition = 'all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1)';
                    
                    // è§¦å‘é‡æ’
                    tempCard.offsetHeight;
                    
                    // ç§»åŠ¨åˆ°ç›®æ ‡ä½ç½®
                    tempCard.style.left = `${targetX}px`;
                    tempCard.style.top = `${targetY}px`;
                    tempCard.style.transform = rotation;
                    
                    // ç­‰å¾…åŠ¨ç”»å®Œæˆ
                    await this.sleep(400);
                    
                    // åŠ¨ç”»å®Œæˆåï¼Œæ·»åŠ åˆ°ç©å®¶æ‰‹ç‰Œï¼ˆæš‚æ—¶ä¸æ›´æ–°æ˜¾ç¤ºï¼Œç­‰å¾…æœ€åç»Ÿä¸€ç†ç‰Œåæ˜¾ç¤ºï¼‰
                    this.playerCards[targetPlayer].push(card);
                    
                    // å‘ç‰Œè¿‡ç¨‹ä¸­ä¸å®æ—¶æ›´æ–°æ˜¾ç¤ºï¼Œé¿å…æ˜¾ç¤ºæœªæ’åºçš„å¡ç‰Œ
                    // åªåœ¨å‘ç‰Œå®Œæˆåç»Ÿä¸€ç†ç‰Œå¹¶æ˜¾ç¤º
                    
                    // ç§»é™¤ä¸´æ—¶å¡ç‰Œ
                    if (tempCard.parentNode) {
                        tempCard.parentNode.removeChild(tempCard);
                    }
                } catch (error) {
                    console.error('å‘ç‰ŒåŠ¨ç”»é”™è¯¯:', error);
                    // ç¡®ä¿å³ä½¿å‡ºé”™ä¹Ÿèƒ½ç»§ç»­æ¸¸æˆ
                    if (tempCard && tempCard.parentNode) {
                        tempCard.parentNode.removeChild(tempCard);
                    }
                }
            }
            
            // æ˜¾ç¤ºåº•ç‰Œï¼ˆå¸¦é£å‡ºåŠ¨ç”»ï¼‰
            async showBottomCardsWithAnimation() {
                console.log('ğŸƒ æ˜¾ç¤ºåº•ç‰Œ');
                
                // æ˜¾ç¤ºåº•ç‰ŒåŒºåŸŸ
                this.elements.bottomCards.style.display = 'flex';
                
                // åº•ç‰Œé£å‡ºåŠ¨ç”»
                for (let i = 0; i < this.bottomCards.length; i++) {
                    const card = this.bottomCards[i];
                    const cardElement = document.getElementById(`bottomCard${i}`);
                    
                    // è®¾ç½®å¡ç‰Œæ ·å¼
                    this.setCardStyle(cardElement, card);
                    
                    // æ·»åŠ é£å‡ºåŠ¨ç”»
                    cardElement.style.animation = `cardFly 0.5s ease-out forwards`;
                    cardElement.style.setProperty('--x', '0px');
                    cardElement.style.setProperty('--y', '-20px');
                    
                    await this.sleep(100);
                }
                
                await this.sleep(500);
            }
            
            // ç†ç‰Œ
            sortCards() {
                const valueOrder = {
                    '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10,
                    'J': 11, 'Q': 12, 'K': 13, 'A': 14, '2': 15,
                    'small': 16, 'big': 17
                };
                
                this.players.forEach(player => {
                    this.playerCards[player].sort((a, b) => {
                        const valueDiff = valueOrder[b.value] - valueOrder[a.value];
                        if (valueDiff !== 0) return valueDiff;
                        
                        const suitOrder = { 'spades': 4, 'hearts': 3, 'clubs': 2, 'diamonds': 1, 'joker': 0 };
                        return suitOrder[b.suit] - suitOrder[a.suit];
                    });
                });
                
                console.log('ğŸ”„ ç†ç‰Œå®Œæˆ - ä»å¤§åˆ°å°æ’åºï¼ˆå³è¾¹æœ€å¤§ï¼Œå·¦è¾¹æœ€å°ï¼‰');
            }
            
            // æ˜¾ç¤ºç©å®¶æ‰‹ç‰Œï¼ˆä¿®å¤è´´å›¾ä¸è·Ÿéšç†ç‰Œå˜åŒ–çš„é—®é¢˜ï¼‰
            showPlayerCards(player) {
                const container = this.elements.playerCards[player];
                container.innerHTML = '';
                
                const cards = this.playerCards[player];
                if (!cards || cards.length === 0) return;
                
                console.log(`ğŸ´ æ˜¾ç¤ºç©å®¶${this.playerNames[player]}çš„æ‰‹ç‰Œï¼Œæ•°é‡: ${cards.length}`);
                
                // éªŒè¯å¡ç‰Œé¡ºåº
                const cardValues = cards.map(c => c.value).join(', ');
                console.log(`ğŸ“Š å½“å‰æ˜¾ç¤ºé¡ºåº: ${cardValues}`);
                
                // ä»å³åˆ°å·¦å †å æ˜¾ç¤ºï¼Œä½¿ç”¨å’Œä¸Šå®¶ç›¸åŒçš„å †å æ•ˆæœ
                const totalCards = cards.length;
                cards.forEach((card, index) => {
                    const cardElement = this.createCardElement(card);
                    
                    // è®¾ç½®å †å æ ·å¼ï¼Œä½¿ç”¨margin-leftè´Ÿå€¼æ¥åˆ›å»ºå †å æ•ˆæœ
                    cardElement.style.marginLeft = '-35px';
                    cardElement.style.zIndex = index; // è°ƒæ•´z-indexï¼Œè®©å³è¾¹çš„ç‰Œåœ¨æœ€ä¸Šé¢
                    
                    // åªæœ‰ç©å®¶è‡ªå·±çš„ç‰Œå¯ä»¥ç‚¹å‡»
                    if (player === 'bottom') {
                        cardElement.classList.add('card-hover', 'cursor-pointer');
                        cardElement.addEventListener('click', () => {
                            this.toggleCardSelection(index);
                        });
                        
                        // å¦‚æœæ˜¯å·²é€‰ä¸­çš„ç‰Œï¼Œæ·»åŠ é€‰ä¸­æ ·å¼
                        if (this.selectedCards.includes(index)) {
                            cardElement.classList.add('card-selected');
                        }
                    }
                    
                    container.appendChild(cardElement);
                });
            }
            
            // æ˜¾ç¤ºAIæ‰‹ç‰Œï¼ˆèƒŒé¢ï¼‰
            showAICards(player) {
                const container = this.elements.playerCards[player];
                container.innerHTML = '';
                
                const cards = this.playerCards[player];
                if (!cards || cards.length === 0) return;
                
                console.log(`ğŸ´ æ˜¾ç¤º${this.playerNames[player]}çš„ç‰Œï¼Œæ•°é‡: ${cards.length}`);
                
                // æ˜¾ç¤ºå®é™…ç‰Œæ•°çš„å †å æ•ˆæœ
                const cardCount = cards.length;
                
                if (player === 'left') {
                    // å·¦ä¾§ç©å®¶ï¼šæ˜¾ç¤ºä¸€å¼ ç‰Œ + æ•°å­—ï¼Œæ¸¸æˆè¿›è¡Œæ—¶ä¸æ”¯æŒé¼ æ ‡æ‚¬åœé¢„è§ˆ
                    if (cardCount > 0) {
                        const cardElement = document.createElement('div');
                        cardElement.className = 'card card-back'; // ç§»é™¤cursor-pointer
                        cardElement.style.transition = 'transform 0.2s ease';
                        
                        // æ¸¸æˆç»“æŸæ—¶æ‰æ˜¾ç¤ºé¢„è§ˆåŠŸèƒ½
                        if (this.gamePhase === 'ended') {
                            cardElement.classList.add('cursor-pointer');
                            cardElement.addEventListener('mouseenter', () => {
                                if (this.showLeftCardsPreview) {
                                    this.showLeftCardsPreview(cards);
                                }
                            });
                            
                            cardElement.addEventListener('mouseleave', () => {
                                if (this.hideLeftCardsPreview) {
                                    this.hideLeftCardsPreview();
                                }
                            });
                        }
                        
                        container.appendChild(cardElement);
                        
                        const countElement = document.createElement('div');
                        countElement.className = 'text-white text-xl font-bold mt-2';
                        countElement.textContent = `Ã—${cardCount}`;
                        container.appendChild(countElement);
                    }
                } else {
                    // é¡¶éƒ¨ç©å®¶ï¼šæ˜¾ç¤ºå®é™…ç‰Œæ•°çš„å †å æ•ˆæœ
                    for (let i = 0; i < cardCount; i++) {
                        const cardElement = document.createElement('div');
                        cardElement.className = 'card card-back';
                        cardElement.style.marginLeft = '-35px';
                        cardElement.style.zIndex = cardCount - i; // åé¢çš„ç‰Œz-indexæ›´å¤§
                        container.appendChild(cardElement);
                    }
                    
                    // æ˜¾ç¤ºç‰Œæ•°æ–‡æœ¬
                    const countElement = document.createElement('div');
                    countElement.className = 'text-white font-bold absolute -right-10 top-1/2 transform -translate-y-1/2';
                    countElement.textContent = `è¿˜æœ‰${cardCount}å¼ `;
                    container.appendChild(countElement);
                }
            }
            
            // æ˜¾ç¤ºå·¦å®¶ç‰Œçš„é¢„è§ˆ
            showLeftCardsPreview(cards) {
                // æ¸…é™¤ä¹‹å‰çš„é¢„è§ˆ
                this.hideLeftCardsPreview();
                
                // åˆ›å»ºé¢„è§ˆå®¹å™¨
                const previewContainer = document.createElement('div');
                previewContainer.id = 'leftCardsPreview';
                previewContainer.className = 'fixed z-50 bg-dark/80 p-4 rounded-lg border border-white/20 backdrop-blur-sm';
                previewContainer.style.cssText = `
                    position: fixed;
                    left: 50%;
                    top: 50%;
                    transform: translate(-50%, -50%);
                    z-index: 1000;
                    background: rgba(10, 25, 47, 0.9);
                    padding: 20px;
                    border-radius: 12px;
                    border: 1px solid rgba(255, 255, 255, 0.2);
                    backdrop-filter: blur(10px);
                    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
                `;
                
                // åˆ›å»ºæ ‡é¢˜
                const title = document.createElement('div');
                title.className = 'text-white font-bold text-lg mb-4 text-center';
                title.textContent = 'å·¦å®¶æ‰‹ç‰Œé¢„è§ˆ';
                previewContainer.appendChild(title);
                
                // åˆ›å»ºå¡ç‰Œå®¹å™¨
                const cardsContainer = document.createElement('div');
                cardsContainer.className = 'flex flex-wrap gap-2 justify-center';
                cardsContainer.style.maxWidth = '400px';
                
                // æ˜¾ç¤ºå¡ç‰Œ
                const sortedCards = [...cards].sort((a, b) => {
                    const valueOrder = {
                        '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10,
                        'J': 11, 'Q': 12, 'K': 13, 'A': 14, '2': 15,
                        'small': 16, 'big': 17
                    };
                    const valueDiff = valueOrder[b.value] - valueOrder[a.value];
                    if (valueDiff !== 0) return valueDiff;
                    const suitOrder = { 'spades': 4, 'hearts': 3, 'clubs': 2, 'diamonds': 1, 'joker': 0 };
                    return suitOrder[b.suit] - suitOrder[a.suit];
                });
                
                sortedCards.forEach(card => {
                    const cardElement = this.createCardElement(card);
                    cardElement.style.width = '40px';
                    cardElement.style.height = '56px';
                    cardElement.style.fontSize = '14px';
                    cardsContainer.appendChild(cardElement);
                });
                
                previewContainer.appendChild(cardsContainer);
                
                // æ·»åŠ åˆ°body
                document.body.appendChild(previewContainer);
            }
            
            // éšè—å·¦å®¶ç‰Œçš„é¢„è§ˆ
            hideLeftCardsPreview() {
                const preview = document.getElementById('leftCardsPreview');
                if (preview) {
                    preview.remove();
                }
            }
            
            // åˆ›å»ºå¡ç‰Œå…ƒç´ 
            createCardElement(card) {
                const cardElement = document.createElement('div');
                this.setCardStyle(cardElement, card);
                return cardElement;
            }
            
            // è®¾ç½®å¡ç‰Œæ ·å¼
            setCardStyle(element, card) {
                // é‡ç½®å…ƒç´ æ ·å¼
                element.className = 'card';
                element.textContent = '';
                element.innerHTML = '';
                
                if (card.suit === 'joker') {
                    element.classList.add('joker');
                    element.style.backgroundColor = card.value === 'big' ? '#ffd700' : '#ff8c00';
                    element.style.color = card.value === 'big' ? '#000000' : '#ffffff';
                    element.style.border = '2px solid #f39c12';
                    element.style.display = 'flex';
                    element.style.alignItems = 'center';
                    element.style.justifyContent = 'space-between';
                    element.style.padding = '0 6px';
                    
                    // åˆ›å»ºåŒ…å«ç¬¦å·å’Œæ–‡å­—çš„å†…å®¹ï¼ˆæ–‡å­—åœ¨å·¦ä¾§ï¼Œæ›´å°å­—å·ï¼‰
                    if (card.value === 'big') {
                        element.innerHTML = '<span style="font-size: 10px; font-weight: bold;">å¤§ç‹</span><span style="font-size: 20px;">ğŸƒ</span>';
                    } else {
                        element.innerHTML = '<span style="font-size: 10px; font-weight: bold;">å°ç‹</span><span style="font-size: 20px;">ğŸƒŸ</span>';
                    }
                } else {
                    const suitSymbols = {
                        'spades': 'â™ ',
                        'hearts': 'â™¥',
                        'clubs': 'â™£',
                        'diamonds': 'â™¦'
                    };
                    
                    element.classList.add(card.suit);
                    element.innerHTML = `
                        <div class="card-value">${card.value}</div>
                        <div class="card-suit">${suitSymbols[card.suit]}</div>
                    `;
                }
                
                element.style.width = this.cardWidth + 'px';
                element.style.height = this.cardHeight + 'px';
            }
            
            // å¼€å§‹å«åœ°ä¸»é˜¶æ®µ
            async startCallingPhase() {
                console.log('ğŸ¤´ å¼€å§‹å«åœ°ä¸»é˜¶æ®µ');
                this.gamePhase = 'calling';
                
                // ç¡®å®šå«åœ°ä¸»é¡ºåºï¼ˆä»å‘ç‰Œèµ·å§‹ç©å®¶å¼€å§‹ï¼‰
                const startPlayerIndex = this.players.indexOf(this.currentPlayer);
                const callingOrder = [];
                for (let i = 0; i < 3; i++) {
                    callingOrder.push(this.players[(startPlayerIndex + i) % 3]);
                }
                
                console.log('ğŸ“‹ å«åœ°ä¸»é¡ºåº:', callingOrder.map(p => this.playerNames[p]).join(' â†’ '));
                
                let hasCall = false;
                
                // æœ€å¤šä¸‰è½®å«åœ°ä¸»
                for (let round = 0; round < 3; round++) {
                    console.log(`\nğŸ”„ ç¬¬${round + 1}è½®å«åœ°ä¸»`);
                    
                    for (const player of callingOrder) {
                        if (hasCall && round > 0) break;
                        
                        console.log(`\nğŸ¯ å½“å‰ç©å®¶: ${player} (${this.playerNames[player]})`);
                        
                        // è®¾ç½®å½“å‰å›åˆç©å®¶
                        this.currentPlayer = player;
                        this.updateStatus(`${this.playerNames[player]}çš„å›åˆ`);
                        
                        // é«˜äº®å½“å‰ç©å®¶
                        this.highlightPlayer(player);
                        
                        // æ˜¾ç¤ºçŠ¶æ€æ–‡æœ¬
                        this.showStatus(player, 'è¯·å«åœ°ä¸»');
                        
                        // æ‰§è¡Œå«åœ°ä¸»æ“ä½œ
                        const called = await this.handlePlayerCall(player);
                        
                        // å–æ¶ˆé«˜äº®
                        this.unhighlightPlayer(player);
                        this.hideStatus(player);
                        
                        if (called) {
                            console.log('ğŸ‘‘', this.playerNames[player], 'æˆä¸ºåœ°ä¸»ï¼');
                            this.landlord = player;
                            hasCall = true;
                            
                            // åœ°ä¸»è·å¾—åº•ç‰Œ
                            this.playerCards[player] = [...this.playerCards[player], ...this.bottomCards];
                            this.sortCards();
                            
                            // é‡æ–°æ˜¾ç¤ºç©å®¶æ‰‹ç‰Œ
                            if (player === 'bottom') {
                                this.showPlayerCards(player);
                            } else {
                                this.showAICards(player);
                            }
                            
                            // æ˜¾ç¤ºåº•ç‰Œå†…å®¹
                            this.revealBottomCards();
                            
                            this.updateStatus(`${this.playerNames[player]}æˆä¸ºåœ°ä¸»ï¼`);
                            
                            // ç«‹å³æ›´æ–°åœ°ä¸»æ ·å¼
                            this.updatePlayerInfo();
                            
                            await this.sleep(2000);
                            
                            // å¼€å§‹å‡ºç‰Œé˜¶æ®µ
                            await this.startPlayingPhase();
                            return;
                        }
                    }
                }
                
                // å¦‚æœæ²¡æœ‰äººå«åœ°ä¸»ï¼Œé‡æ–°å¼€å§‹æ¸¸æˆ
                console.log('âŒ æ— äººå«åœ°ä¸»ï¼Œé‡æ–°å¼€å§‹');
                this.updateStatus('æ— äººå«åœ°ä¸»ï¼Œé‡æ–°å¼€å§‹');
                await this.sleep(2000);
                this.startGame();
            }
            
            // å¤„ç†ç©å®¶å«åœ°ä¸»
            async handlePlayerCall(player) {
                if (player === 'bottom') {
                    return await this.handleHumanCall();
                } else {
                    return await this.handleAICall(player);
                }
            }
            
            // å¤„ç†äººç±»å«åœ°ä¸»
            async handleHumanCall() {
                return new Promise((resolve) => {
                    // æ¸…ç©ºæŒ‰é’®å®¹å™¨
                    this.elements.actionButtons.innerHTML = '';
                    
                    // ç¡®ä¿æŒ‰é’®å®¹å™¨æ ·å¼æ­£ç¡®
                    this.elements.actionButtons.style.cssText = `
                        display: flex !important;
                        justify-content: center !important;
                        align-items: center !important;
                        gap: 15px !important;
                        margin: 15px 0 !important;
                        min-height: 60px !important;
                        position: relative !important;
                        z-index: 9999 !important;
                        background: rgba(0, 0, 0, 0.1) !important;
                        border-radius: 10px !important;
                        padding: 10px !important;
                        pointer-events: auto !important;
                    `;
                    
                    // åˆ›å»ºå«åœ°ä¸»æŒ‰é’®
                    const callBtn = document.createElement('button');
                    callBtn.className = 'bg-accent hover:bg-orange-600 text-white px-8 py-4 rounded-lg font-bold transition-all duration-300 transform hover:scale-105 shadow-lg text-xl';
                    callBtn.textContent = 'å«åœ°ä¸»';
                    callBtn.onclick = () => {
                        this.landlord = 'bottom';
                        this.showStatus('bottom', 'å«åœ°ä¸» âœ“');
                        
                        // æ¸…ç©ºæŒ‰é’®å®¹å™¨
                        this.elements.actionButtons.innerHTML = '';
                        this.elements.actionButtons.style.pointerEvents = 'none';
                        
                        resolve(true);
                    };
                    
                    // åˆ›å»ºä¸å«æŒ‰é’®
                    const passBtn = document.createElement('button');
                    passBtn.className = 'bg-gray-600 hover:bg-gray-700 text-white px-8 py-4 rounded-lg font-bold transition-all duration-300 transform hover:scale-105 shadow-lg text-xl';
                    passBtn.textContent = 'ä¸å«';
                    passBtn.onclick = () => {
                        this.showStatus('bottom', 'ä¸å«');
                        
                        // æ¸…ç©ºæŒ‰é’®å®¹å™¨
                        this.elements.actionButtons.innerHTML = '';
                        this.elements.actionButtons.style.pointerEvents = 'none';
                        
                        resolve(false);
                    };
                    
                    // æ·»åŠ æŒ‰é’®
                    this.elements.actionButtons.appendChild(callBtn);
                    this.elements.actionButtons.appendChild(passBtn);
                });
            }
            
            // å¤„ç†AIå«åœ°ä¸»
            async handleAICall(player) {
                // ç®€å•çš„AIå†³ç­–é€»è¾‘
                const cards = this.playerCards[player];
                let score = 0;
                
                // è®¡ç®—ç‰ŒåŠ›åˆ†æ•°
                cards.forEach(card => {
                    if (card.value === '2') score += 2;
                    else if (card.value === 'A') score += 1.5;
                    else if (card.value === 'K') score += 1;
                    else if (card.value === 'Q') score += 0.8;
                    else if (card.value === 'J') score += 0.6;
                    else if (card.value === '10') score += 0.5;
                    else if (card.suit === 'joker') score += 5;
                });
                
                // éšæœºå› ç´ 
                const randomFactor = Math.random() * 2;
                
                await this.sleep(1000);
                
                const willCall = score + randomFactor > 8;
                
                if (willCall) {
                    this.showStatus(player, 'å«åœ°ä¸» âœ“');
                } else {
                    this.showStatus(player, 'ä¸å«');
                }
                
                return willCall;
            }
            
            // æ˜¾ç¤ºåº•ç‰Œå†…å®¹
            revealBottomCards() {
                this.bottomCards.forEach((card, index) => {
                    const cardElement = document.getElementById(`bottomCard${index}`);
                    this.setCardStyle(cardElement, card);
                    cardElement.classList.add('animate-glow');
                });
            }
            
            // å¼€å§‹å‡ºç‰Œé˜¶æ®µ
            async startPlayingPhase() {
                console.log('ğŸ® å¼€å§‹å‡ºç‰Œé˜¶æ®µ');
                this.gamePhase = 'playing';
                
                // åœ°ä¸»å…ˆå‡ºç‰Œ
                this.currentPlayer = this.landlord;
                this.passCount = 0;
                this.currentCards = null;
                this.currentCardsPlayer = null;
                this.selectedCards = [];
                
                // æ¸…ç©ºæŒ‰é’®å®¹å™¨å¹¶å¯ç”¨
                this.elements.actionButtons.innerHTML = '';
                this.elements.actionButtons.style.pointerEvents = 'auto';
                
                this.updateStatus(`${this.playerNames[this.currentPlayer]}çš„å›åˆ`);
                
                // å¼€å§‹å¼‚æ­¥æ¸¸æˆå¾ªç¯
                await this.gameLoop();
            }
            
            // å¼‚æ­¥æ¸¸æˆå¾ªç¯
            async gameLoop() {
                // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
                if (this.checkGameEnd()) {
                    return;
                }
                
                // å›åˆå¼€å§‹æ—¶é‡æ–°ç†ç‰Œå¹¶æ›´æ–°æ˜¾ç¤º
                console.log(`ğŸ”„ ${this.playerNames[this.currentPlayer]}å›åˆå¼€å§‹ - é‡æ–°ç†ç‰Œ`);
                this.sortCards();
                
                // æ›´æ–°ç©å®¶æ‰‹ç‰Œæ˜¾ç¤º
                if (this.currentPlayer === 'bottom') {
                    this.showPlayerCards(this.currentPlayer);
                } else {
                    this.showAICards(this.currentPlayer);
                }
                
                // é«˜äº®å½“å‰ç©å®¶
                this.highlightPlayer(this.currentPlayer);
                
                // æ‰§è¡Œå‡ºç‰Œæ“ä½œ
                const action = await this.handlePlayerAction();
                
                // å–æ¶ˆé«˜äº®
                this.unhighlightPlayer(this.currentPlayer);
                
                // æ¸…é™¤ä»»ä½•å¯èƒ½å­˜åœ¨çš„é¢„è§ˆ
                if (this.hideLeftCardsPreview) {
                    this.hideLeftCardsPreview();
                }
                
                if (action.type === 'play') {
                    // ç©å®¶å‡ºç‰Œ
                    this.currentCards = action.cards;
                    this.currentCardsPlayer = this.currentPlayer;
                    this.passCount = 0;
                    
                    // æ˜¾ç¤ºå‡ºç‰Œ
                    this.showCurrentCards(this.currentPlayer, action.cards);
                    
                    // æ›´æ–°ç©å®¶ä¿¡æ¯ï¼ˆç‰Œæ•°ï¼‰
                    this.updatePlayerInfo();
                    
                    // ä»ç©å®¶æ‰‹ç‰Œä¸­ç§»é™¤
                    action.cards.forEach(card => {
                        const index = this.playerCards[this.currentPlayer].findIndex(c => 
                            c.suit === card.suit && c.value === card.value
                        );
                        if (index > -1) {
                            this.playerCards[this.currentPlayer].splice(index, 1);
                        }
                    });
                    
                    // æ›´æ–°æ˜¾ç¤ºï¼ˆå…ˆé‡æ–°ç†ç‰Œå†æ˜¾ç¤ºï¼‰
                    if (this.currentPlayer === 'bottom') {
                        this.sortCards(); // é‡æ–°ç†ç‰Œ
                        this.showPlayerCards(this.currentPlayer);
                    } else {
                        this.sortCards(); // é‡æ–°ç†ç‰Œ
                        this.showAICards(this.currentPlayer);
                    }
                    
                    this.updateStatus(`${this.playerNames[this.currentPlayer]}å‡ºç‰Œ`);
                } else {
                    // ç©å®¶è·³è¿‡
                    this.passCount++;
                    this.showStatus(this.currentPlayer, 'è¦ä¸èµ·');
                    this.updateStatus(`${this.playerNames[this.currentPlayer]}è¦ä¸èµ·`);
                }
                
                // æ£€æŸ¥æ˜¯å¦è¿›å…¥è‡ªç”±ç‰Œé˜¶æ®µ
                if (this.passCount >= 2) {
                    console.log('ğŸ”„ è¿›å…¥è‡ªç”±ç‰Œé˜¶æ®µ');
                    this.currentCards = null;
                    this.currentCardsPlayer = null;
                    this.passCount = 0;
                    this.updateStatus('è‡ªç”±ç‰Œé˜¶æ®µ');
                    
                    // æ¸…é™¤å½“å‰å‡ºç‰Œæ˜¾ç¤º
                    this.clearCurrentCards();
                    
                    await this.sleep(1000);
                }
                
                // ä¸‹ä¸€ä¸ªç©å®¶
                this.nextPlayer();
                
                // ç»§ç»­ä¸‹ä¸€è½®å¾ªç¯
                await this.gameLoop();
            }
            
            // åˆ‡æ¢AIæ‰˜ç®¡æ¨¡å¼
            toggleAIMode() {
                this.aiMode = !this.aiMode;
                const btn = this.elements.aiModeBtn;
                
                if (this.aiMode) {
                    btn.textContent = 'AIæ‰˜ç®¡: å¼€å¯';
                    btn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                    btn.classList.add('bg-green-600', 'hover:bg-green-700');
                    this.updateStatus('AIæ‰˜ç®¡æ¨¡å¼å·²å¼€å¯');
                    console.log('ğŸ¤– AIæ‰˜ç®¡æ¨¡å¼å·²å¼€å¯');
                    
                    // å¦‚æœå½“å‰æ˜¯ç©å®¶å›åˆï¼Œç«‹å³æ‰§è¡ŒAIæ“ä½œ
                    if (this.gamePhase === 'playing' && this.currentPlayer === 'bottom') {
                        setTimeout(() => {
                            this.handlePlayerAction();
                        }, 500);
                    }
                } else {
                    btn.textContent = 'AIæ‰˜ç®¡: å…³é—­';
                    btn.classList.remove('bg-green-600', 'hover:bg-green-700');
                    btn.classList.add('bg-blue-600', 'hover:bg-blue-700');
                    this.updateStatus('AIæ‰˜ç®¡æ¨¡å¼å·²å…³é—­');
                    console.log('ğŸ‘¤ AIæ‰˜ç®¡æ¨¡å¼å·²å…³é—­');
                }
            }
            
            // AIæ‰˜ç®¡æ¨¡å¼ä¸‹ä¸ºç©å®¶å‡ºç‰Œï¼ˆä¿®å¤å¤æ‚ç‰Œå‹å¤„ç†ï¼‰
            async handleAIActionForHuman() {
                const cards = [...this.playerCards.bottom];
                const playerType = this.landlord === 'bottom' ? 'landlord' : 'farmer';
                
                console.log(`ğŸ¤– AIæ‰˜ç®¡å†³ç­– - æ‰‹ç‰Œæ•°: ${cards.length}, ç±»å‹: ${playerType}`);
                
                // æ¨¡æ‹Ÿæ€è€ƒæ—¶é—´
                await this.sleep(800 + Math.random() * 800);
                
                try {
                    // ä½¿ç”¨å¢å¼ºç‰ˆå†³ç­–é€»è¾‘ï¼Œæ”¯æŒå¤æ‚ç‰Œå‹
                    if (!this.currentCards || this.currentCards.length === 0) {
                        // è‡ªç”±ç‰Œé˜¶æ®µ - ä½¿ç”¨å¢å¼ºç‰ˆæ‰¾ç‰Œ
                        const bestCombo = this.findBestComboInFreePhase(cards);
                        
                        if (bestCombo.length > 0) {
                            await this.sleep(300);
                            this.showStatus('bottom', 'å‡ºç‰Œ');
                            console.log(`âœ… AIæ‰˜ç®¡è‡ªç”±ç‰Œé˜¶æ®µå‡ºç‰Œ: ${bestCombo.map(c => c.value).join(', ')}`);
                            return { type: 'play', cards: bestCombo };
                        } else {
                            // è‡ªç”±ç‰Œé˜¶æ®µå¿…å‡º
                            console.log('âš ï¸  AIæ‰˜ç®¡è‡ªç”±ç‰Œé˜¶æ®µå¼ºåˆ¶å‡ºç‰Œ');
                            this.showStatus('bottom', 'å‡ºç‰Œ');
                            return { type: 'play', cards: [cards[0]] };
                        }
                    } else {
                        // å¯¹æ‰“é˜¶æ®µ - ä½¿ç”¨å¢å¼ºç‰ˆæ‰¾ç‰Œï¼ˆæ”¯æŒå¤æ‚ç‰Œå‹ï¼‰
                        const currentCardType = this.getCardType(this.currentCards);
                        console.log(`ğŸ‘€ AIæ‰˜ç®¡å¯¹æ‰“é˜¶æ®µ - å½“å‰å‡ºç‰Œ: ${this.currentCards.map(c => c.value).join(', ')} (ç±»å‹: ${currentCardType.name})`);
                        
                        // 1. æ£€æŸ¥æ˜¯å¦æœ‰ç‚¸å¼¹å¯ä»¥ç‚¸
                        const bombs = this.findBombs(cards);
                        const hasRoyalBomb = cards.some(c => c.value === 'big') && cards.some(c => c.value === 'small');
                        
                        // ç‹ç‚¸ç­–ç•¥
                        if (hasRoyalBomb) {
                            const shouldUseRoyalBomb = this.shouldUseRoyalBombNow(cards, currentCardType, playerType);
                            if (shouldUseRoyalBomb) {
                                console.log('ğŸ‘‘ AIæ‰˜ç®¡ä½¿ç”¨ç‹ç‚¸ç‚¸ç‰Œ');
                                await this.sleep(300);
                                this.showStatus('bottom', 'å‡ºç‰Œ');
                                return { type: 'play', cards: cards.filter(c => c.value === 'big' || c.value === 'small') };
                            }
                        }
                        
                        // ç‚¸å¼¹ç­–ç•¥
                        if (bombs.length > 0) {
                            const shouldUseBomb = this.shouldUseBombNow(bombs, currentCardType, cards, playerType);
                            if (shouldUseBomb) {
                                console.log('ğŸ’£ AIæ‰˜ç®¡ä½¿ç”¨ç‚¸å¼¹ç‚¸ç‰Œ');
                                await this.sleep(300);
                                this.showStatus('bottom', 'å‡ºç‰Œ');
                                return { type: 'play', cards: bombs[0] };
                            }
                        }
                        
                        // 2. ä½¿ç”¨å¢å¼ºç‰ˆæ‰¾ç‰Œå‡½æ•°ï¼ˆæ”¯æŒå¤æ‚ç‰Œå‹ï¼‰
                        const playableCards = this.findPlayableCardsAdvanced(cards, this.currentCards, currentCardType, playerType);
                        
                        // å¦‚æœå¢å¼ºç‰ˆæ‰¾ä¸åˆ°ï¼Œå°è¯•åŸºç¡€ç‰ˆ
                        if (playableCards.length === 0) {
                            const basicPlayable = this.findPlayableCards(cards, this.currentCards, currentCardType, playerType);
                            if (basicPlayable.length > 0) {
                                console.log(`âœ… AIæ‰˜ç®¡æ‰¾åˆ°åŸºç¡€å¯å‹ç‰Œ: ${basicPlayable.map(c => c.value).join(', ')}`);
                                await this.sleep(300);
                                this.showStatus('bottom', 'å‡ºç‰Œ');
                                return { type: 'play', cards: basicPlayable };
                            }
                        }
                        
                        if (playableCards.length > 0) {
                            await this.sleep(300);
                            this.showStatus('bottom', 'å‡ºç‰Œ');
                            console.log(`âœ… AIæ‰˜ç®¡å¯¹æ‰“é˜¶æ®µå‡ºç‰Œ: ${playableCards.map(c => c.value).join(', ')}`);
                            return { type: 'play', cards: playableCards };
                        } else {
                            console.log('âŒ AIæ‰˜ç®¡æ— æ³•å‹ç‰Œ');
                            this.showStatus('bottom', 'è¦ä¸èµ·');
                            return { type: 'pass' };
                        }
                    }
                } catch (error) {
                    console.error('ğŸ¤– AIæ‰˜ç®¡å†³ç­–å‡ºé”™:', error);
                    // å‡ºé”™æ—¶å…œåº•ç­–ç•¥
                    this.showStatus('bottom', 'è¦ä¸èµ·');
                    return { type: 'pass' };
                }
            }
            
            // å¤„ç†ç©å®¶æ“ä½œ
            async handlePlayerAction() {
                if (this.currentPlayer === 'bottom' && this.aiMode) {
                    // AIæ‰˜ç®¡æ¨¡å¼ä¸‹ï¼Œç©å®¶å›åˆç”±AIè‡ªåŠ¨å¤„ç†
                    console.log('ğŸ¤– AIæ‰˜ç®¡æ¨¡å¼ - è‡ªåŠ¨ä¸ºç©å®¶å‡ºç‰Œ');
                    this.showStatus('bottom', 'AIå‡ºç‰Œä¸­...');
                    await this.sleep(1000);
                    return await this.handleAIActionForHuman();
                } else if (this.currentPlayer === 'bottom') {
                    return await this.handleHumanAction();
                } else {
                    return await this.handleAIAction();
                }
            }
            
            // å¤„ç†äººç±»æ“ä½œ
            async handleHumanAction() {
                return new Promise((resolve) => {
                    // æ¸…ç©ºæŒ‰é’®å®¹å™¨
                    this.elements.actionButtons.innerHTML = '';
                    
                    // åˆ›å»ºå‡ºç‰ŒæŒ‰é’®
                    const playBtn = document.createElement('button');
                    playBtn.className = 'action-btn';
                    playBtn.textContent = 'å‡ºç‰Œ';
                    playBtn.style.cssText = `
                        background: linear-gradient(135deg, #0066cc, #004499);
                        color: white;
                        border: 2px solid #0066cc;
                        padding: 12px 24px;
                        font-size: 16px;
                        font-weight: bold;
                        border-radius: 8px;
                        cursor: pointer;
                        margin: 0 5px;
                        transition: all 0.3s ease;
                    `;
                    playBtn.onclick = () => {
                        if (this.selectedCards.length > 0 && this.validateCards(this.selectedCards)) {
                            resolve({ type: 'play', cards: [...this.selectedCards] });
                            this.selectedCards = [];
                        }
                    };
                    
                    // åªåœ¨éè‡ªç”±ç‰Œé˜¶æ®µæ˜¾ç¤ºè¦ä¸èµ·æŒ‰é’®
                    if (this.currentCards && this.currentCards.length > 0) {
                        const passBtn = document.createElement('button');
                        passBtn.className = 'action-btn pass';
                        passBtn.textContent = 'è¦ä¸èµ·';
                        passBtn.style.cssText = `
                            background: linear-gradient(135deg, #666, #999);
                            color: white;
                            border: 2px solid #666;
                            padding: 12px 24px;
                            font-size: 16px;
                            font-weight: bold;
                            border-radius: 8px;
                            cursor: pointer;
                            margin: 0 5px;
                            transition: all 0.3s ease;
                        `;
                        passBtn.onclick = () => {
                            this.selectedCards = []; // æ¸…é™¤é€‰æ‹©è®°å½•
                            resolve({ type: 'pass' });
                        };
                        
                        // ç¡®ä¿æŒ‰é’®å®¹å™¨æ ·å¼æ­£ç¡®
                        this.elements.actionButtons.style.cssText = `
                            display: flex !important;
                            justify-content: center !important;
                            align-items: center !important;
                            gap: 10px !important;
                            margin: 10px 0 !important;
                        `;
                        
                        // æ·»åŠ æŒ‰é’®
                        this.elements.actionButtons.appendChild(playBtn);
                        this.elements.actionButtons.appendChild(passBtn);
                    } else {
                        // è‡ªç”±ç‰Œé˜¶æ®µåªæ˜¾ç¤ºå‡ºç‰ŒæŒ‰é’®
                        this.elements.actionButtons.style.cssText = `
                            display: flex !important;
                            justify-content: center !important;
                            align-items: center !important;
                            margin: 10px 0 !important;
                        `;
                        
                        // æ·»åŠ æŒ‰é’®
                        this.elements.actionButtons.appendChild(playBtn);
                        
                        // æç¤ºç©å®¶å¿…é¡»å‡ºç‰Œ
                        this.updateStatus('è‡ªç”±ç‰Œé˜¶æ®µï¼Œè¯·å‡ºç‰Œ');
                    }
                });
            }
            
            // å¤„ç†AIæ“ä½œ - å¢å¼ºç‰ˆï¼ˆæ·»åŠ è¶…æ—¶ä¿æŠ¤ï¼‰
            async handleAIAction() {
                const playerType = this.currentPlayer === this.landlord ? 'landlord' : 'farmer';
                const cards = [...this.playerCards[this.currentPlayer]];
                
                console.log(`ğŸ¤– AIå†³ç­– - ç©å®¶: ${this.currentPlayer}, ç±»å‹: ${playerType}, æ‰‹ç‰Œæ•°: ${cards.length}`);
                
                // æ˜¾ç¤ºAIæ€è€ƒçŠ¶æ€
                this.showStatus(this.currentPlayer, 'æ€è€ƒä¸­...');
                
                // è®¾ç½®æ€è€ƒæ—¶é—´ä¸Šé™
                const maxThinkTime = 2000; // æœ€å¤§æ€è€ƒ2ç§’
                
                try {
                    // ä½¿ç”¨Promise.raceæ·»åŠ è¶…æ—¶ä¿æŠ¤
                    const result = await Promise.race([
                        this.makeAIDecision(cards, playerType),
                        new Promise((_, reject) => 
                            setTimeout(() => reject(new Error('AIæ€è€ƒè¶…æ—¶')), maxThinkTime)
                        )
                    ]);
                    
                    return result;
                } catch (error) {
                    console.warn('âš ï¸ AIå†³ç­–è¶…æ—¶ï¼Œé»˜è®¤é€‰æ‹©ä¸å‡º', error);
                    this.showStatus(this.currentPlayer, 'ä¸å‡º');
                    return { type: 'pass' };
                }
            }
            
            // AIå†³ç­–é€»è¾‘ - ä¼˜åŒ–ç‰ˆï¼ˆåŒºåˆ†å¯¹æ‰“å’Œè‡ªç”±ç‰Œé˜¶æ®µï¼‰
            async makeAIDecision(cards, playerType) {
                console.log(`ğŸ¤– AIå†³ç­–å¼€å§‹ - ç©å®¶: ${this.currentPlayer}, ç±»å‹: ${playerType}, æ‰‹ç‰Œæ•°: ${cards.length}`);
                
                // æ¨¡æ‹Ÿæ€è€ƒæ—¶é—´
                await this.sleep(800 + Math.random() * 800);
                
                // æ£€æŸ¥æ˜¯å¦æœ‰å½“å‰å‡ºç‰Œ
                if (!this.currentCards || this.currentCards.length === 0) {
                    // ========== è‡ªç”±ç‰Œé˜¶æ®µ ==========
                    console.log('ğŸ”„ è‡ªç”±ç‰Œé˜¶æ®µ - å¿…å‡ºç­–ç•¥');
                    
                    // è‡ªç”±ç‰Œé˜¶æ®µå¿…å‡ºï¼Œä¸å…è®¸ä¸å‡º
                    const bestCombo = this.findBestComboInFreePhase(cards);
                    
                    if (bestCombo.length > 0) {
                        await this.sleep(300);
                        this.showStatus(this.currentPlayer, 'å‡ºç‰Œ');
                        console.log(`âœ… è‡ªç”±ç‰Œé˜¶æ®µå‡ºç‰Œ: ${bestCombo.map(c => c.value).join(', ')}`);
                        return { type: 'play', cards: bestCombo };
                    } else {
                        // ç†è®ºä¸Šä¸åº”è¯¥åˆ°è¾¾è¿™é‡Œï¼Œå› ä¸ºè‡ªç”±ç‰Œé˜¶æ®µå¿…å‡º
                        console.log('âŒ è‡ªç”±ç‰Œé˜¶æ®µæ²¡æœ‰æ‰¾åˆ°å¯å‡ºç‰Œï¼ˆå¼‚å¸¸æƒ…å†µï¼‰');
                        this.showStatus(this.currentPlayer, 'å‡ºç‰Œ');
                        return { type: 'play', cards: [cards[0]] }; // å¼ºåˆ¶å‡ºç¬¬ä¸€å¼ ç‰Œ
                    }
                } else {
                    // ========== å¯¹æ‰“é˜¶æ®µ ==========
                    console.log('âš”ï¸  å¯¹æ‰“é˜¶æ®µ - ç­–ç•¥æ€§å‡ºç‰Œ');
                    
                    const currentCardType = this.getCardType(this.currentCards);
                    console.log(`ğŸ‘€ å½“å‰å‡ºç‰Œ: ${this.currentCards.map(c => c.value).join(', ')} (ç±»å‹: ${currentCardType.name})`);
                    
                    // 1. æ£€æŸ¥æ˜¯å¦æœ‰ç‚¸å¼¹å¯ä»¥ç‚¸
                    const bombs = this.findBombs(cards);
                    const hasRoyalBomb = cards.some(c => c.value === 'big') && cards.some(c => c.value === 'small');
                    
                    // ç‹ç‚¸ç­–ç•¥ï¼šåªåœ¨å…³é”®æ—¶åˆ»ä½¿ç”¨
                    if (hasRoyalBomb) {
                        const shouldUseRoyalBomb = this.shouldUseRoyalBombNow(cards, currentCardType, playerType);
                        if (shouldUseRoyalBomb) {
                            console.log('ğŸ‘‘ ä½¿ç”¨ç‹ç‚¸ç‚¸ç‰Œ');
                            await this.sleep(300);
                            this.showStatus(this.currentPlayer, 'å‡ºç‰Œ');
                            return { type: 'play', cards: cards.filter(c => c.value === 'big' || c.value === 'small') };
                        }
                    }
                    
                    // ç‚¸å¼¹ç­–ç•¥ï¼šç­–ç•¥æ€§ä½¿ç”¨
                    if (bombs.length > 0) {
                        const shouldUseBomb = this.shouldUseBombNow(bombs, currentCardType, cards, playerType);
                        if (shouldUseBomb) {
                            console.log('ğŸ’£ ä½¿ç”¨ç‚¸å¼¹ç‚¸ç‰Œ');
                            await this.sleep(300);
                            this.showStatus(this.currentPlayer, 'å‡ºç‰Œ');
                            return { type: 'play', cards: bombs[0] };
                        }
                    }
                    
                    // 2. å¯»æ‰¾å¯å‹çš„ç‰Œ - å¢å¼ºç‰ˆï¼ˆæ”¯æŒå¤æ‚ç‰Œå‹ï¼‰
                    const playableCards = this.findPlayableCardsAdvanced(cards, this.currentCards, currentCardType, playerType);
                    
                    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°å¯å‹çš„ç‰Œï¼Œå°è¯•ä½¿ç”¨åŸºç¡€å‡ºç‰Œå‡½æ•°
                    if (playableCards.length === 0) {
                        const basicPlayable = this.findPlayableCards(cards, this.currentCards, currentCardType, playerType);
                        if (basicPlayable.length > 0) {
                            console.log(`âœ… æ‰¾åˆ°åŸºç¡€å¯å‹ç‰Œ: ${basicPlayable.map(c => c.value).join(', ')}`);
                            return basicPlayable;
                        }
                    }
                    
                    if (playableCards.length > 0) {
                        // å†œæ°‘é…åˆç­–ç•¥
                        if (playerType === 'farmer') {
                            const currentPlayer = this.currentCardsPlayer;
                            const teammate = this.getTeammate(this.currentPlayer);
                            
                            // å¦‚æœæ˜¯é˜Ÿå‹å‡ºçš„ç‰Œï¼Œä¸”é˜Ÿå‹ç‰Œå¾ˆå°‘ï¼Œè€ƒè™‘ä¸å‡ºç‰Œè®©é˜Ÿå‹ç»§ç»­
                            if (currentPlayer === teammate) {
                                const teammateCards = this.playerCards[teammate].length;
                                const cardRank = this.getValueRank(this.currentCards[0].value);
                                
                                if (teammateCards <= 3 && cardRank >= this.getValueRank('K')) {
                                    console.log('ğŸ¤ é˜Ÿå‹ç‰Œå°‘ä¸”å‡ºå¤§ç‰Œï¼Œä¸å‡ºç‰Œè®©é˜Ÿå‹ç»§ç»­');
                                    this.showStatus(this.currentPlayer, 'è¦ä¸èµ·');
                                    return { type: 'pass' };
                                }
                            }
                        }
                        
                        console.log(`âœ… é€‰æ‹©å‹ç‰Œ: ${playableCards.map(c => c.value).join(', ')}`);
                        await this.sleep(300);
                        this.showStatus(this.currentPlayer, 'å‡ºç‰Œ');
                        return { type: 'play', cards: playableCards };
                    } else {
                        // 3. æ— æ³•å‹ç‰Œæ—¶ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰ç»å¯¹æœºä¼šç­–ç•¥
                        const hasAbsoluteChance = this.checkAbsoluteChance(cards, this.getValueCounts(cards));
                        
                        if (hasAbsoluteChance) {
                            // æœ‰ç»å¯¹æœºä¼šæ—¶ï¼Œé€‰æ‹©ä¸å‡ºç‰Œç­‰å¾…æœºä¼š
                            console.log('ğŸ¯ æ‰§è¡Œç»å¯¹æœºä¼šç­–ç•¥ - ç­‰å¾…æœºä¼šï¼Œé€‰æ‹©è¦ä¸èµ·');
                            this.showStatus(this.currentPlayer, 'è¦ä¸èµ·');
                            return { type: 'pass' };
                        } else {
                            // æ£€æŸ¥æ˜¯å¦æœ‰æ•Œäººå³å°†è·èƒœï¼ˆåªå‰©1-2å¼ ç‰Œï¼‰
                            const hasEnemyAboutToWin = this.checkEnemyCardCount(1, 2);
                            
                            if (hasEnemyAboutToWin) {
                                // æ•Œäººå³å°†è·èƒœæ—¶ï¼Œå³ä½¿æœ‰ç»å¯¹æœºä¼šä¹Ÿå¿…é¡»å‡ºç‰Œé˜»æ­¢
                                console.log('ğŸš¨ æ•Œäººå³å°†è·èƒœï¼Œå¿…é¡»å‡ºç‰Œé˜»æ­¢');
                                
                                // å¯»æ‰¾æœ€å°çš„å¯å‡ºç‰Œ
                                const smallestCard = [...cards].sort((a, b) => 
                                    this.getValueRank(a.value) - this.getValueRank(b.value)
                                )[0];
                                
                                this.showStatus(this.currentPlayer, 'å‡ºç‰Œé˜»æ­¢');
                                return { type: 'play', cards: [smallestCard] };
                            } else {
                                // æ²¡æœ‰ç»å¯¹æœºä¼šæ—¶ï¼Œæ­£å¸¸é€‰æ‹©è¦ä¸èµ·
                                console.log('âŒ æ— æ³•å‹ç‰Œï¼Œé€‰æ‹©è¦ä¸èµ·');
                                this.showStatus(this.currentPlayer, 'è¦ä¸èµ·');
                                return { type: 'pass' };
                            }
                        }
                    }
                }
            }
            
            // è‡ªç”±ç‰Œé˜¶æ®µæ‰¾ç‰Œ - å¢å¼ºç‰ˆï¼ˆæ”¯æŒå¤æ‚ç‰Œå‹ï¼‰
            findBestComboInFreePhase(cards) {
                console.log(`ğŸ¯ è‡ªç”±ç‰Œé˜¶æ®µæ‰¾ç‰Œ - æ‰‹ç‰Œæ•°: ${cards.length}`);
                
                // å¤åˆ¶æ‰‹ç‰Œè¿›è¡Œåˆ†æï¼Œé¿å…ä¿®æ”¹åŸæ•°ç»„
                const sortedCards = [...cards].sort((a, b) => this.getValueRank(a.value) - this.getValueRank(b.value));
                const cardValues = sortedCards.map(card => card.value);
                
                // ç»Ÿè®¡æ¯ç§ç‰Œçš„æ•°é‡
                const valueCounts = {};
                cardValues.forEach(value => {
                    valueCounts[value] = (valueCounts[value] || 0) + 1;
                });
                
                console.log('ğŸ“Š æ‰‹ç‰Œåˆ†å¸ƒ:', valueCounts);
                
                // å…¨æ–°ç­–ç•¥ï¼šæ£€æŸ¥æ˜¯å¦æœ‰ç»å¯¹æœºä¼šï¼ˆå¤§å°ç‹+ç‚¸å¼¹+å¤§ç»„åˆï¼‰
                const hasAbsoluteChance = this.checkAbsoluteChance(sortedCards, valueCounts);
                if (hasAbsoluteChance) {
                    const trashCard = this.findTrashCardToPlay(sortedCards, valueCounts);
                    if (trashCard) {
                        console.log(`ğŸ¯ æ‰§è¡Œç»å¯¹æœºä¼šç­–ç•¥ - å…ˆå‡ºæ‚ç‰Œ: ${trashCard.value}`);
                        return [trashCard];
                    }
                }
                
                // æ£€æŸ¥æ˜¯å¦å¯ä»¥ä¸€æ¬¡æ€§å‡ºå®Œæ‰€æœ‰ç‰Œ
                const canFinishAll = this.canFinishAllCards(sortedCards, valueCounts);
                if (canFinishAll) {
                    console.log('ğŸ† å¯ä»¥ä¸€æ¬¡æ€§å‡ºå®Œæ‰€æœ‰ç‰Œï¼');
                    return sortedCards;
                }
                
                // ç­–ç•¥1ï¼šæ£€æŸ¥é£æœºå¸¦ç¿…è†€ï¼ˆæœ€ä¼˜å…ˆï¼‰
                const airplaneWithWings = this.findAirplaneWithWings(sortedCards, valueCounts);
                if (airplaneWithWings.length > 0) {
                    const bestAirplane = airplaneWithWings.sort((a, b) => b.length - a.length)[0];
                    console.log(`âœˆï¸  é€‰æ‹©å‡ºé£æœºå¸¦ç¿…è†€: ${bestAirplane.map(c => c.value).join(', ')}`);
                    return bestAirplane;
                }
                
                // ç­–ç•¥2ï¼šæ£€æŸ¥é£æœº
                const airplanes = this.findAirplanes(sortedCards, valueCounts);
                if (airplanes.length > 0) {
                    const bestAirplane = airplanes.sort((a, b) => b.length - a.length)[0];
                    console.log(`âœˆï¸  é€‰æ‹©å‡ºé£æœº: ${bestAirplane.map(c => c.value).join(', ')}`);
                    return bestAirplane;
                }
                
                // ç­–ç•¥3ï¼šæ£€æŸ¥é¡ºå­
                const validStraights = this.findStraights(sortedCards).filter(s => s.length >= 5 && s.length <= 12);
                if (validStraights.length > 0) {
                    // ä¼˜å…ˆå‡ºè¾ƒçŸ­çš„é¡ºå­ï¼ˆ5-6å¼ ï¼‰
                    const shortStraights = validStraights.filter(s => s.length <= 6);
                    if (shortStraights.length > 0) {
                        const bestStraight = shortStraights.sort((a, b) => a.length - b.length)[0];
                        console.log(`ğŸ“ é€‰æ‹©å‡ºçŸ­é¡ºå­: ${bestStraight.map(c => c.value).join(', ')} (é•¿åº¦:${bestStraight.length})`);
                        return bestStraight;
                    } else {
                        // æ²¡æœ‰çŸ­é¡ºå­æ—¶å‡ºæœ€é•¿çš„é¡ºå­
                        const longestStraight = validStraights.sort((a, b) => b.length - a.length)[0];
                        console.log(`ğŸ“ é€‰æ‹©å‡ºé¡ºå­: ${longestStraight.map(c => c.value).join(', ')} (é•¿åº¦:${longestStraight.length})`);
                        return longestStraight;
                    }
                }
                
                // ç­–ç•¥4ï¼šæ£€æŸ¥ä¸‰å¸¦ä¸€å’Œä¸‰å¸¦äºŒï¼ˆä¸æ‹†ä¸‰2å’Œä¸‰Aé™¤éèƒ½ä¸€æ¬¡æ€§å‡ºå®Œï¼‰
                const threeWithAttachments = this.findThreeWithAttachments(sortedCards, valueCounts);
                if (threeWithAttachments.length > 0) {
                    // ä¼˜å…ˆé€‰æ‹©å¯ä»¥ä¸€æ¬¡æ€§å‡ºå®Œçš„ç»„åˆ
                    const finishable = threeWithAttachments.filter(combo => this.canFinishWithCombo(sortedCards, combo, valueCounts));
                    if (finishable.length > 0) {
                        const bestCombo = finishable[0];
                        console.log(`ğŸ¯ é€‰æ‹©å‡ºä¸‰å¸¦ï¼ˆå¯ä¸€æ¬¡æ€§å‡ºå®Œï¼‰: ${bestCombo.map(c => c.value).join(', ')}`);
                        return bestCombo;
                    }
                    
                    // å¦åˆ™é€‰æ‹©æ™®é€šä¸‰å¸¦ï¼ˆé¿å¼€ä¸‰2å’Œä¸‰Aï¼‰
                    const normalThreeWith = threeWithAttachments.filter(combo => {
                        const tripleValue = combo[0].value;
                        return tripleValue !== '2' && tripleValue !== 'A';
                    });
                    
                    if (normalThreeWith.length > 0) {
                        const bestCombo = normalThreeWith[0];
                        console.log(`ğŸ¯ é€‰æ‹©å‡ºä¸‰å¸¦: ${bestCombo.map(c => c.value).join(', ')}`);
                        return bestCombo;
                    }
                }
                
                // ç­–ç•¥4.5ï¼šæ£€æŸ¥è¿å¯¹ï¼ˆæ”¯æŒ2å¯¹åŠä»¥ä¸Šï¼‰
                const straightPairs = this.findStraightPairs(sortedCards);
                if (straightPairs.length > 0) {
                    // ä¼˜å…ˆå‡ºè¾ƒçŸ­çš„è¿å¯¹ï¼ˆ2-3å¯¹ï¼‰ï¼Œé¿å¼€2ã€Aã€K
                    const shortStraightPairs = straightPairs.filter(s => s.length <= 6); // 2-3å¯¹
                    
                    if (shortStraightPairs.length > 0) {
                        // è¿‡æ»¤æ‰åŒ…å«2ã€Aã€Kçš„è¿å¯¹
                        const safeShortPairs = shortStraightPairs.filter(pair => {
                            const hasHighCards = pair.some(card => 
                                card.value === '2' || card.value === 'A' || card.value === 'K'
                            );
                            // å¦‚æœåŒ…å«é«˜ç‰Œï¼Œåªæœ‰èƒ½ä¸€æ¬¡æ€§å‡ºå®Œæ—¶æ‰è€ƒè™‘
                            if (hasHighCards) {
                                return this.canFinishWithCombo(sortedCards, pair, valueCounts);
                            }
                            return true;
                        });
                        
                        if (safeShortPairs.length > 0) {
                            const bestStraightPair = safeShortPairs.sort((a, b) => a.length - b.length)[0];
                            console.log(`ğŸ‘¥ é€‰æ‹©å‡ºå®‰å…¨çŸ­è¿å¯¹: ${bestStraightPair.map(c => c.value).join(', ')} (é•¿åº¦:${bestStraightPair.length/2}å¯¹)`);
                            return bestStraightPair;
                        } else if (shortStraightPairs.length > 0) {
                            // å¦‚æœæ²¡æœ‰å®‰å…¨çš„è¿å¯¹ï¼Œä½†æœ‰åŒ…å«é«˜ç‰Œçš„è¿å¯¹ä¸”èƒ½ä¸€æ¬¡æ€§å‡ºå®Œ
                            const finishablePairs = shortStraightPairs.filter(pair => 
                                this.canFinishWithCombo(sortedCards, pair, valueCounts)
                            );
                            if (finishablePairs.length > 0) {
                                const bestStraightPair = finishablePairs[0];
                                console.log(`ğŸ† é€‰æ‹©å‡ºé«˜ç‰Œè¿å¯¹ï¼ˆå¯ä¸€æ¬¡æ€§å‡ºå®Œï¼‰: ${bestStraightPair.map(c => c.value).join(', ')}`);
                                return bestStraightPair;
                            }
                        }
                    } else if (straightPairs.length > 0) {
                        // æ²¡æœ‰çŸ­è¿å¯¹æ—¶ï¼Œæ‰¾é•¿è¿å¯¹ï¼ŒåŒæ ·é¿å¼€é«˜ç‰Œ
                        const safeLongPairs = straightPairs.filter(pair => {
                            const hasHighCards = pair.some(card => 
                                card.value === '2' || card.value === 'A' || card.value === 'K'
                            );
                            // å¦‚æœåŒ…å«é«˜ç‰Œï¼Œåªæœ‰èƒ½ä¸€æ¬¡æ€§å‡ºå®Œæ—¶æ‰è€ƒè™‘
                            if (hasHighCards) {
                                return this.canFinishWithCombo(sortedCards, pair, valueCounts);
                            }
                            return true;
                        });
                        
                        if (safeLongPairs.length > 0) {
                            const longestStraightPair = safeLongPairs.sort((a, b) => b.length - a.length)[0];
                            console.log(`ğŸ‘¥ é€‰æ‹©å‡ºå®‰å…¨é•¿è¿å¯¹: ${longestStraightPair.map(c => c.value).join(', ')} (é•¿åº¦:${longestStraightPair.length/2}å¯¹)`);
                            return longestStraightPair;
                        } else {
                            // å¦‚æœæ²¡æœ‰å®‰å…¨çš„é•¿è¿å¯¹ï¼Œä½†æœ‰åŒ…å«é«˜ç‰Œçš„è¿å¯¹ä¸”èƒ½ä¸€æ¬¡æ€§å‡ºå®Œ
                            const finishablePairs = straightPairs.filter(pair => 
                                this.canFinishWithCombo(sortedCards, pair, valueCounts)
                            );
                            if (finishablePairs.length > 0) {
                                const bestStraightPair = finishablePairs[0];
                                console.log(`ğŸ† é€‰æ‹©å‡ºé«˜ç‰Œé•¿è¿å¯¹ï¼ˆå¯ä¸€æ¬¡æ€§å‡ºå®Œï¼‰: ${bestStraightPair.map(c => c.value).join(', ')}`);
                                return bestStraightPair;
                            }
                        }
                    }
                }
                
                // ç­–ç•¥5ï¼šä¼˜å…ˆå‡ºå•ç‰Œï¼Œä½†ä¸æ‹†ä¸‰å¼ å’Œå››å¼ 
                const singleCards = sortedCards.filter(card => {
                    const count = valueCounts[card.value];
                    return count === 1; // åªå‡ºå•å¼ çš„ç‰Œ
                });
                
                if (singleCards.length > 0) {
                    // æ£€æŸ¥æ˜¯å¦æœ‰æ•Œäººåªå‰©1-3å¼ ç‰Œ
                    const hasLowCardEnemy = this.checkEnemyCardCount(1, 3);
                    
                    if (hasLowCardEnemy) {
                        // æ•Œäººç‰Œå°‘æ—¶ï¼Œä¼˜å…ˆå‡ºå¤§ç‰Œå‹åˆ¶
                        const bigSingleCards = singleCards.filter(card => 
                            this.getValueRank(card.value) >= this.getValueRank('J')
                        );
                        
                        if (bigSingleCards.length > 0) {
                            // é€‰æ‹©æœ€å°çš„å¤§ç‰Œæ¥å‹åˆ¶
                            bigSingleCards.sort((a, b) => this.getValueRank(a.value) - this.getValueRank(b.value));
                            console.log(`ğŸ‘Š æ•Œäººç‰Œå°‘ï¼Œé€‰æ‹©å‡ºå¤§ç‰Œå‹åˆ¶: ${bigSingleCards[0].value}`);
                            return [bigSingleCards[0]];
                        }
                    }
                    
                    // æ­£å¸¸æƒ…å†µï¼šä¼˜å…ˆå‡º3ï¼Œä½†é¿å¼€4å¼ 3çš„æƒ…å†µ
                    const threeCards = singleCards.filter(card => card.value === '3');
                    if (threeCards.length > 0 && valueCounts['3'] !== 4) {
                        console.log(`ğŸƒ ä¼˜å…ˆå‡ºå•ç‰Œ3: ${threeCards[0].value}`);
                        return [threeCards[0]];
                    }
                    
                    // å‡ºæœ€å°çš„å…¶ä»–å•ç‰Œ
                    const otherSingles = singleCards.filter(card => card.value !== '3');
                    if (otherSingles.length > 0) {
                        console.log(`ğŸƒ é€‰æ‹©å‡ºå•ç‰Œ: ${otherSingles[0].value} (ä¸æ‹†ä¸‰å¼ /å››å¼ )`);
                        return [otherSingles[0]];
                    } else if (threeCards.length > 0) {
                        // å¦‚æœåªæœ‰3ä¸”æ˜¯4å¼ 3ï¼Œæš‚æ—¶ä¸å‡º3
                        console.log(`ğŸ›¡ï¸  4å¼ 3ï¼Œæš‚æ—¶ä¸å‡ºå•ç‰Œ3`);
                    }
                }
                
                // ç­–ç•¥6ï¼šå‡ºå¯¹å­ï¼Œä½†ä¸æ‹†ä¸‰å¼ å’Œå››å¼ 
                const pairCandidates = [];
                Object.keys(valueCounts).forEach(value => {
                    if (valueCounts[value] === 2) { // åªå‡ºåˆšå¥½æˆå¯¹çš„ç‰Œ
                        const pair = sortedCards.filter(card => card.value === value);
                        pairCandidates.push(pair);
                    }
                });
                
                if (pairCandidates.length > 0) {
                    // é€‰æ‹©æœ€å°çš„å¯¹å­
                    pairCandidates.sort((a, b) => this.getValueRank(a[0].value) - this.getValueRank(b[0].value));
                    console.log(`ğŸ‘¥ é€‰æ‹©å‡ºå¯¹å­: ${pairCandidates[0][0].value} (ä¸æ‹†ä¸‰å¼ /å››å¼ )`);
                    return pairCandidates[0];
                }
                
                // ç­–ç•¥7ï¼šå‡ºä¸‰å¼ ï¼ˆå®Œæ•´çš„ä¸‰å¼ ï¼Œé¿å¼€ä¸‰2å’Œä¸‰Aé™¤éèƒ½ä¸€æ¬¡æ€§å‡ºå®Œï¼‰
                const tripleCandidates = [];
                Object.keys(valueCounts).forEach(value => {
                    if (valueCounts[value] === 3) { // åˆšå¥½ä¸‰å¼ çš„ç‰Œ
                        // ä¸‰2å’Œä¸‰Aé€šå¸¸æ‹†å¼€ä½¿ç”¨ï¼Œé™¤éèƒ½ä¸€æ¬¡æ€§å‡ºå®Œ
                        if ((value === '2' || value === 'A') && !this.canFinishWithTriple(sortedCards, value, valueCounts)) {
                            return; // è·³è¿‡ä¸‰2å’Œä¸‰A
                        }
                        const triple = sortedCards.filter(card => card.value === value);
                        tripleCandidates.push(triple);
                    }
                });
                
                if (tripleCandidates.length > 0) {
                    // é€‰æ‹©æœ€å°çš„ä¸‰å¼ 
                    tripleCandidates.sort((a, b) => this.getValueRank(a[0].value) - this.getValueRank(b[0].value));
                    console.log(`ğŸ´ é€‰æ‹©å‡ºä¸‰å¼ : ${tripleCandidates[0][0].value}`);
                    return tripleCandidates[0];
                }
                
                // ç­–ç•¥8ï¼šå‡ºå››å¼ ï¼ˆç‚¸å¼¹ï¼‰
                const bombCandidates = [];
                Object.keys(valueCounts).forEach(value => {
                    if (valueCounts[value] === 4) { // åˆšå¥½å››å¼ çš„ç‰Œ
                        const bomb = sortedCards.filter(card => card.value === value);
                        bombCandidates.push(bomb);
                    }
                });
                
                if (bombCandidates.length > 0) {
                    // é€‰æ‹©æœ€å°çš„ç‚¸å¼¹
                    bombCandidates.sort((a, b) => this.getValueRank(a[0].value) - this.getValueRank(b[0].value));
                    console.log(`ğŸ’£ é€‰æ‹©å‡ºç‚¸å¼¹: ${bombCandidates[0][0].value}`);
                    return bombCandidates[0];
                }
                
                // ç­–ç•¥9ï¼šå¤„ç†ç‰¹æ®Šæƒ…å†µï¼ˆå¿…é¡»æ‹†ç‰Œçš„æƒ…å†µï¼‰
                // å½“æ‰€æœ‰ç‰Œéƒ½æ˜¯å¤šå¼ æ—¶ï¼Œéœ€è¦æ‹†ç‰Œ
                const multiCards = sortedCards.filter(card => valueCounts[card.value] >= 2);
                if (multiCards.length > 0) {
                    // æ‰¾å‡ºæ•°é‡æœ€å¤šçš„ç‰Œå‹
                    let maxCount = 0;
                    let maxCountValue = null;
                    
                    Object.keys(valueCounts).forEach(value => {
                        if (valueCounts[value] > maxCount) {
                            maxCount = valueCounts[value];
                            maxCountValue = value;
                        }
                    });
                    
                    // ä»æœ€å¤šçš„ç‰Œå‹ä¸­æ‹†å‡ºæœ€å°çš„ç‰Œ
                    const cardToPlay = sortedCards.find(card => card.value === maxCountValue);
                    console.log(`âš ï¸  å¿…é¡»æ‹†ç‰Œï¼Œä» ${maxCountValue} (æ•°é‡:${maxCount}) ä¸­æ‹†å‡ºä¸€å¼ `);
                    return [cardToPlay];
                }
                
                // ç­–ç•¥10ï¼šæœ€åçš„é€‰æ‹©ï¼ˆç†è®ºä¸Šä¸ä¼šåˆ°è¾¾è¿™é‡Œï¼‰
                if (sortedCards.length > 0) {
                    console.log(`ğŸš¨ æœ€ç»ˆé€‰æ‹©ï¼Œå‡ºæœ€å°çš„ç‰Œ: ${sortedCards[0].value}`);
                    return [sortedCards[0]];
                }
                
                console.log('âŒ æ²¡æœ‰ç‰Œå¯å‡ºï¼ˆå¼‚å¸¸æƒ…å†µï¼‰');
                return [];
            }
            
            // è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥æ˜¯å¦å¯ä»¥ä¸€æ¬¡æ€§å‡ºå®Œæ‰€æœ‰ç‰Œ
            canFinishAllCards(cards, valueCounts) {
                // ç®€å•æ£€æŸ¥ï¼šå¦‚æœåªæœ‰ä¸€ç§ç‰Œå‹ä¸”æ•°é‡ç¬¦åˆå‡ºç‰Œè§„åˆ™
                const uniqueValues = Object.keys(valueCounts);
                
                if (uniqueValues.length === 1) {
                    const count = valueCounts[uniqueValues[0]];
                    return count === 1 || count === 2 || count === 3 || count === 4;
                }
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯å®Œæ•´çš„é¡ºå­
                const straight = this.findStraights(cards);
                if (straight.length > 0 && straight[0].length === cards.length) {
                    return true;
                }
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯å®Œæ•´çš„é£æœºå¸¦ç¿…è†€
                const airplaneWithWings = this.findAirplaneWithWings(cards, valueCounts);
                if (airplaneWithWings.length > 0 && airplaneWithWings[0].length === cards.length) {
                    return true;
                }
                
                return false;
            }
            
            // è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥ä¸‰å¸¦æ˜¯å¦å¯ä»¥å¸®åŠ©ä¸€æ¬¡æ€§å‡ºå®Œ
            canFinishWithTriple(allCards, tripleValue, valueCounts) {
                const remainingCards = allCards.filter(card => card.value !== tripleValue);
                if (remainingCards.length === 0) return true;
                
                // æ£€æŸ¥å‰©ä½™ç‰Œæ˜¯å¦å¯ä»¥ä¸€èµ·å‡ºå®Œ
                const remainingCounts = {};
                remainingCards.forEach(card => {
                    remainingCounts[card.value] = (remainingCounts[card.value] || 0) + 1;
                });
                
                // å¯ä»¥å¸¦å•ç‰Œæˆ–å¯¹å­
                const singleCount = Object.values(remainingCounts).filter(c => c === 1).length;
                const pairCount = Object.values(remainingCounts).filter(c => c === 2).length;
                
                return singleCount <= 1 && pairCount <= 1;
            }
            
            // è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥ç»„åˆæ˜¯å¦å¯ä»¥å¸®åŠ©ä¸€æ¬¡æ€§å‡ºå®Œ
            canFinishWithCombo(allCards, combo, valueCounts) {
                const comboValues = combo.map(c => c.value);
                const remainingCards = allCards.filter(card => !comboValues.includes(card.value));
                return remainingCards.length === 0;
            }
            
            // æŸ¥æ‰¾ä¸‰å¸¦ä¸€å’Œä¸‰å¸¦äºŒ
            findThreeWithAttachments(cards, valueCounts) {
                const result = [];
                const tripleValues = Object.keys(valueCounts).filter(v => valueCounts[v] === 3);
                
                tripleValues.forEach(tripleValue => {
                    const triple = cards.filter(c => c.value === tripleValue);
                    
                    // æ‰¾å•ç‰Œä½œä¸ºé™„ä»¶
                    const singleCards = cards.filter(c => c.value !== tripleValue && valueCounts[c.value] === 1);
                    if (singleCards.length >= 1) {
                        const bestSingle = singleCards.sort((a, b) => this.getValueRank(a.value) - this.getValueRank(b.value))[0];
                        result.push([...triple, bestSingle]);
                    }
                    
                    // æ‰¾å¯¹å­ä½œä¸ºé™„ä»¶
                    const pairCards = [];
                    Object.keys(valueCounts).forEach(v => {
                        if (v !== tripleValue && valueCounts[v] === 2) {
                            pairCards.push(...cards.filter(c => c.value === v));
                        }
                    });
                    if (pairCards.length >= 2) {
                        const bestPair = pairCards.slice(0, 2);
                        result.push([...triple, ...bestPair]);
                    }
                });
                
                return result;
            }
            
            // æŸ¥æ‰¾é£æœº
            findAirplanes(cards, valueCounts) {
                const result = [];
                const tripleValues = Object.keys(valueCounts).filter(v => valueCounts[v] === 3);
                
                // æŒ‰å€¼æ’åº
                tripleValues.sort((a, b) => this.getValueRank(a) - this.getValueRank(b));
                
                // æŸ¥æ‰¾è¿ç»­çš„ä¸‰å¼ 
                for (let i = 0; i <= tripleValues.length - 2; i++) {
                    if (this.getValueRank(tripleValues[i + 1]) - this.getValueRank(tripleValues[i]) === 1) {
                        // æ‰¾åˆ°ä¸¤ç»„è¿ç»­çš„ä¸‰å¼ 
                        const airplane = [
                            ...cards.filter(c => c.value === tripleValues[i]),
                            ...cards.filter(c => c.value === tripleValues[i + 1])
                        ];
                        result.push(airplane);
                        
                        // æ£€æŸ¥æ˜¯å¦æœ‰ä¸‰ç»„è¿ç»­çš„ä¸‰å¼ 
                        if (i + 2 < tripleValues.length && 
                            this.getValueRank(tripleValues[i + 2]) - this.getValueRank(tripleValues[i + 1]) === 1) {
                            const airplane3 = [
                                ...airplane,
                                ...cards.filter(c => c.value === tripleValues[i + 2])
                            ];
                            result.push(airplane3);
                        }
                    }
                }
                
                return result;
            }
            
            // æŸ¥æ‰¾é£æœºå¸¦ç¿…è†€
            findAirplaneWithWings(cards, valueCounts) {
                const result = [];
                const airplanes = this.findAirplanes(cards, valueCounts);
                
                airplanes.forEach(airplane => {
                    const airplaneValues = [...new Set(airplane.map(c => c.value))];
                    const airplaneLength = airplaneValues.length;
                    
                    // æ‰¾å•ç‰Œä½œä¸ºç¿…è†€
                    const singleCards = cards.filter(c => !airplaneValues.includes(c.value) && valueCounts[c.value] === 1);
                    if (singleCards.length >= airplaneLength) {
                        const bestSingles = singleCards
                            .sort((a, b) => this.getValueRank(a.value) - this.getValueRank(b.value))
                            .slice(0, airplaneLength);
                        result.push([...airplane, ...bestSingles]);
                    }
                    
                    // æ‰¾å¯¹å­ä½œä¸ºç¿…è†€
                    const pairCards = [];
                    Object.keys(valueCounts).forEach(v => {
                        if (!airplaneValues.includes(v) && valueCounts[v] === 2) {
                            pairCards.push(...cards.filter(c => c.value === v));
                        }
                    });
                    
                    if (pairCards.length >= airplaneLength * 2) {
                        const bestPairs = pairCards.slice(0, airplaneLength * 2);
                        result.push([...airplane, ...bestPairs]);
                    }
                });
                
                return result;
            }
            
            // å¢å¼ºç‰ˆæŸ¥æ‰¾å¯å‡ºç‰Œå‡½æ•°ï¼ˆæ”¯æŒå¤æ‚ç‰Œå‹å¯¹æ‰“ï¼‰
            findPlayableCardsAdvanced(cards, currentCards, currentCardType, playerType) {
                console.log(`ğŸ¯ æŸ¥æ‰¾å¯å‹ç‰Œ - å½“å‰ç‰Œå‹: ${currentCardType.name}, é•¿åº¦: ${currentCardType.length}`);
                
                // é¦–å…ˆå°è¯•ä½¿ç”¨åŸæœ‰çš„åŸºç¡€å‡ºç‰Œå‡½æ•°
                const basicPlayable = this.findPlayableCards(cards, currentCards, currentCardType, playerType);
                if (basicPlayable.length > 0) {
                    console.log(`âœ… æ‰¾åˆ°åŸºç¡€å¯å‹ç‰Œ: ${basicPlayable.map(c => c.value).join(', ')}`);
                    return basicPlayable;
                }
                
                // ç»Ÿè®¡æ‰‹ç‰Œåˆ†å¸ƒ
                const cardValues = cards.map(card => card.value);
                const valueCounts = {};
                cardValues.forEach(value => {
                    valueCounts[value] = (valueCounts[value] || 0) + 1;
                });
                
                // æ ¹æ®å½“å‰ç‰Œå‹å¯»æ‰¾ç‰¹å®šçš„å¯å‹ç‰Œ
                switch (currentCardType.name) {
                    case 'ä¸‰å¸¦ä¸€':
                        return this.findPlayableThreeWithOne(cards, currentCards, currentCardType, valueCounts);
                        
                    case 'ä¸‰å¸¦äºŒ':
                        return this.findPlayableThreeWithTwo(cards, currentCards, currentCardType, valueCounts);
                        
                    case 'é£æœº':
                        return this.findPlayableAirplane(cards, currentCards, currentCardType, valueCounts);
                        
                    case 'é£æœºå¸¦å•':
                        return this.findPlayableAirplaneWithSingles(cards, currentCards, currentCardType, valueCounts);
                        
                    case 'é£æœºå¸¦å¯¹':
                        return this.findPlayableAirplaneWithPairs(cards, currentCards, currentCardType, valueCounts);
                        
                    default:
                        // å¯¹äºå…¶ä»–ç‰Œå‹ï¼Œè¿”å›ç©ºæ•°ç»„
                        console.log(`âŒ æ²¡æœ‰æ‰¾åˆ°å¯å‹çš„${currentCardType.name}`);
                        return [];
                }
            }
            
            // æŸ¥æ‰¾å¯å‹çš„ä¸‰å¸¦ä¸€
            findPlayableThreeWithOne(cards, currentCards, currentCardType, valueCounts) {
                console.log('ğŸ” æŸ¥æ‰¾å¯å‹ä¸‰å¸¦ä¸€');
                
                // æå–å½“å‰ä¸‰å¸¦ä¸€çš„ä¸‰å¼ ç‰Œå€¼
                const currentTripleValue = currentCards.find(card => 
                    currentCards.filter(c => c.value === card.value).length === 3
                ).value;
                const currentTripleRank = this.getValueRank(currentTripleValue);
                
                // æŸ¥æ‰¾æ‰‹ç‰Œä¸­æ‰€æœ‰çš„ä¸‰å¼ 
                const tripleValues = Object.keys(valueCounts).filter(v => valueCounts[v] === 3);
                const higherTriples = tripleValues.filter(v => this.getValueRank(v) > currentTripleRank);
                
                if (higherTriples.length === 0) {
                    console.log('âŒ æ²¡æœ‰æ›´å¤§çš„ä¸‰å¼ æ¥å‹ä¸‰å¸¦ä¸€');
                    return [];
                }
                
                // é€‰æ‹©æœ€å°çš„æ›´å¤§çš„ä¸‰å¼ 
                higherTriples.sort((a, b) => this.getValueRank(a) - this.getValueRank(b));
                const bestTripleValue = higherTriples[0];
                const tripleCards = cards.filter(c => c.value === bestTripleValue);
                
                // å¯»æ‰¾å¯ä»¥å¸¦çš„å•ç‰Œï¼ˆé€‰æ‹©æœ€å°çš„å•ç‰Œï¼‰
                const singleCards = cards.filter(c => 
                    c.value !== bestTripleValue && valueCounts[c.value] === 1
                );
                
                if (singleCards.length === 0) {
                    console.log('âŒ æ²¡æœ‰å•ç‰Œå¯å¸¦');
                    return [];
                }
                
                const bestSingle = singleCards.sort((a, b) => 
                    this.getValueRank(a.value) - this.getValueRank(b.value)
                )[0];
                
                const playableCombo = [...tripleCards, bestSingle];
                console.log(`âœ… æ‰¾åˆ°å¯å‹ä¸‰å¸¦ä¸€: ${playableCombo.map(c => c.value).join(', ')}`);
                return playableCombo;
            }
            
            // æŸ¥æ‰¾å¯å‹çš„ä¸‰å¸¦äºŒ
            findPlayableThreeWithTwo(cards, currentCards, currentCardType, valueCounts) {
                console.log('ğŸ” æŸ¥æ‰¾å¯å‹ä¸‰å¸¦äºŒ');
                
                // æå–å½“å‰ä¸‰å¸¦äºŒçš„ä¸‰å¼ ç‰Œå€¼
                const currentTripleValue = currentCards.find(card => 
                    currentCards.filter(c => c.value === card.value).length === 3
                ).value;
                const currentTripleRank = this.getValueRank(currentTripleValue);
                
                // æŸ¥æ‰¾æ‰‹ç‰Œä¸­æ‰€æœ‰çš„ä¸‰å¼ 
                const tripleValues = Object.keys(valueCounts).filter(v => valueCounts[v] === 3);
                const higherTriples = tripleValues.filter(v => this.getValueRank(v) > currentTripleRank);
                
                if (higherTriples.length === 0) {
                    console.log('âŒ æ²¡æœ‰æ›´å¤§çš„ä¸‰å¼ æ¥å‹ä¸‰å¸¦äºŒ');
                    return [];
                }
                
                // é€‰æ‹©æœ€å°çš„æ›´å¤§çš„ä¸‰å¼ 
                higherTriples.sort((a, b) => this.getValueRank(a) - this.getValueRank(b));
                const bestTripleValue = higherTriples[0];
                const tripleCards = cards.filter(c => c.value === bestTripleValue);
                
                // å¯»æ‰¾å¯ä»¥å¸¦çš„å¯¹å­ï¼ˆé€‰æ‹©æœ€å°çš„å¯¹å­ï¼‰
                const pairValues = Object.keys(valueCounts).filter(v => 
                    v !== bestTripleValue && valueCounts[v] === 2
                );
                
                if (pairValues.length === 0) {
                    console.log('âŒ æ²¡æœ‰å¯¹å­å¯å¸¦');
                    return [];
                }
                
                const bestPairValue = pairValues.sort((a, b) => 
                    this.getValueRank(a) - this.getValueRank(b)
                )[0];
                const pairCards = cards.filter(c => c.value === bestPairValue);
                
                const playableCombo = [...tripleCards, ...pairCards];
                console.log(`âœ… æ‰¾åˆ°å¯å‹ä¸‰å¸¦äºŒ: ${playableCombo.map(c => c.value).join(', ')}`);
                return playableCombo;
            }
            
            // æŸ¥æ‰¾å¯å‹çš„é£æœº
            findPlayableAirplane(cards, currentCards, currentCardType, valueCounts) {
                console.log('ğŸ” æŸ¥æ‰¾å¯å‹é£æœº');
                
                // åˆ†æå½“å‰é£æœº
                const currentTripleValues = [];
                const valueGroups = {};
                currentCards.forEach(card => {
                    valueGroups[card.value] = (valueGroups[card.value] || 0) + 1;
                });
                
                Object.keys(valueGroups).forEach(value => {
                    if (valueGroups[value] === 3) {
                        currentTripleValues.push(value);
                    }
                });
                
                currentTripleValues.sort((a, b) => this.getValueRank(a) - this.getValueRank(b));
                const currentAirplaneLength = currentTripleValues.length;
                const currentMaxRank = this.getValueRank(currentTripleValues[currentTripleValues.length - 1]);
                
                console.log(`ğŸ“Š å½“å‰é£æœº: ${currentTripleValues.join(', ')}, é•¿åº¦: ${currentAirplaneLength}`);
                
                // æŸ¥æ‰¾æ‰‹ç‰Œä¸­çš„é£æœº
                const airplanes = this.findAirplanes(cards, valueCounts);
                const playableAirplanes = airplanes.filter(airplane => {
                    // åˆ†æé£æœºç»“æ„
                    const airplaneValueGroups = {};
                    airplane.forEach(card => {
                        airplaneValueGroups[card.value] = (airplaneValueGroups[card.value] || 0) + 1;
                    });
                    
                    const airplaneTripleValues = Object.keys(airplaneValueGroups).filter(v => airplaneValueGroups[v] === 3);
                    airplaneTripleValues.sort((a, b) => this.getValueRank(a) - this.getValueRank(b));
                    
                    // é•¿åº¦å¿…é¡»ç›¸åŒ
                    if (airplaneTripleValues.length !== currentAirplaneLength) {
                        return false;
                    }
                    
                    // æœ€å¤§ç‰Œå€¼å¿…é¡»æ›´å¤§
                    const airplaneMaxRank = this.getValueRank(airplaneTripleValues[airplaneTripleValues.length - 1]);
                    return airplaneMaxRank > currentMaxRank;
                });
                
                if (playableAirplanes.length === 0) {
                    console.log('âŒ æ²¡æœ‰æ‰¾åˆ°å¯å‹çš„é£æœº');
                    return [];
                }
                
                // é€‰æ‹©æœ€å°çš„å¯å‹é£æœº
                const bestAirplane = playableAirplanes.sort((a, b) => {
                    const aValueGroups = {};
                    a.forEach(card => {
                        aValueGroups[card.value] = (aValueGroups[card.value] || 0) + 1;
                    });
                    const aTripleValues = Object.keys(aValueGroups).filter(v => aValueGroups[v] === 3);
                    aTripleValues.sort((x, y) => this.getValueRank(x) - this.getValueRank(y));
                    
                    const bValueGroups = {};
                    b.forEach(card => {
                        bValueGroups[card.value] = (bValueGroups[card.value] || 0) + 1;
                    });
                    const bTripleValues = Object.keys(bValueGroups).filter(v => bValueGroups[v] === 3);
                    bTripleValues.sort((x, y) => this.getValueRank(x) - this.getValueRank(y));
                    
                    return this.getValueRank(aTripleValues[0]) - this.getValueRank(bTripleValues[0]);
                })[0];
                
                console.log(`âœ… æ‰¾åˆ°å¯å‹é£æœº: ${bestAirplane.map(c => c.value).join(', ')}`);
                return bestAirplane;
            }
            
            // æŸ¥æ‰¾å¯å‹çš„é£æœºå¸¦å•
            findPlayableAirplaneWithSingles(cards, currentCards, currentCardType, valueCounts) {
                console.log('ğŸ” æŸ¥æ‰¾å¯å‹é£æœºå¸¦å•');
                
                // åˆ†æå½“å‰é£æœºå¸¦å•çš„ç»“æ„
                const currentTripleValues = [];
                const valueGroups = {};
                currentCards.forEach(card => {
                    valueGroups[card.value] = (valueGroups[card.value] || 0) + 1;
                });
                
                Object.keys(valueGroups).forEach(value => {
                    if (valueGroups[value] === 3) {
                        currentTripleValues.push(value);
                    }
                });
                
                currentTripleValues.sort((a, b) => this.getValueRank(a) - this.getValueRank(b));
                const currentAirplaneLength = currentTripleValues.length;
                const currentMaxRank = this.getValueRank(currentTripleValues[currentTripleValues.length - 1]);
                
                console.log(`ğŸ“Š å½“å‰é£æœºå¸¦å•: é£æœºéƒ¨åˆ†${currentTripleValues.join(', ')}, é•¿åº¦: ${currentAirplaneLength}`);
                
                // å…ˆæ‰¾åˆ°å¯å‹çš„é£æœº
                const baseAirplane = this.findPlayableAirplane(cards, currentCards, currentCardType, valueCounts);
                if (baseAirplane.length === 0) {
                    return [];
                }
                
                // åˆ†ææ‰¾åˆ°çš„é£æœº
                const airplaneValueGroups = {};
                baseAirplane.forEach(card => {
                    airplaneValueGroups[card.value] = (airplaneValueGroups[card.value] || 0) + 1;
                });
                const airplaneTripleValues = Object.keys(airplaneValueGroups).filter(v => airplaneValueGroups[v] === 3);
                
                // å¯»æ‰¾å¯ä»¥å¸¦çš„å•ç‰Œ
                const availableSingles = cards.filter(c => 
                    !airplaneTripleValues.includes(c.value) && valueCounts[c.value] === 1
                );
                
                if (availableSingles.length < currentAirplaneLength) {
                    console.log('âŒ å•ç‰Œæ•°é‡ä¸è¶³');
                    return [];
                }
                
                // é€‰æ‹©æœ€å°çš„å•ç‰Œ
                const bestSingles = availableSingles
                    .sort((a, b) => this.getValueRank(a.value) - this.getValueRank(b.value))
                    .slice(0, currentAirplaneLength);
                
                const playableCombo = [...baseAirplane, ...bestSingles];
                console.log(`âœ… æ‰¾åˆ°å¯å‹é£æœºå¸¦å•: ${playableCombo.map(c => c.value).join(', ')}`);
                return playableCombo;
            }
            
            // æŸ¥æ‰¾å¯å‹çš„é£æœºå¸¦å¯¹
            findPlayableAirplaneWithPairs(cards, currentCards, currentCardType, valueCounts) {
                console.log('ğŸ” æŸ¥æ‰¾å¯å‹é£æœºå¸¦å¯¹');
                
                // åˆ†æå½“å‰é£æœºå¸¦å¯¹çš„ç»“æ„
                const currentTripleValues = [];
                const valueGroups = {};
                currentCards.forEach(card => {
                    valueGroups[card.value] = (valueGroups[card.value] || 0) + 1;
                });
                
                Object.keys(valueGroups).forEach(value => {
                    if (valueGroups[value] === 3) {
                        currentTripleValues.push(value);
                    }
                });
                
                currentTripleValues.sort((a, b) => this.getValueRank(a) - this.getValueRank(b));
                const currentAirplaneLength = currentTripleValues.length;
                const currentMaxRank = this.getValueRank(currentTripleValues[currentTripleValues.length - 1]);
                
                console.log(`ğŸ“Š å½“å‰é£æœºå¸¦å¯¹: é£æœºéƒ¨åˆ†${currentTripleValues.join(', ')}, é•¿åº¦: ${currentAirplaneLength}`);
                
                // å…ˆæ‰¾åˆ°å¯å‹çš„é£æœº
                const baseAirplane = this.findPlayableAirplane(cards, currentCards, currentCardType, valueCounts);
                if (baseAirplane.length === 0) {
                    return [];
                }
                
                // åˆ†ææ‰¾åˆ°çš„é£æœº
                const airplaneValueGroups = {};
                baseAirplane.forEach(card => {
                    airplaneValueGroups[card.value] = (airplaneValueGroups[card.value] || 0) + 1;
                });
                const airplaneTripleValues = Object.keys(airplaneValueGroups).filter(v => airplaneValueGroups[v] === 3);
                
                // å¯»æ‰¾å¯ä»¥å¸¦çš„å¯¹å­
                const availablePairs = [];
                Object.keys(valueCounts).forEach(value => {
                    if (!airplaneTripleValues.includes(value) && valueCounts[value] === 2) {
                        availablePairs.push(...cards.filter(c => c.value === value));
                    }
                });
                
                if (availablePairs.length < currentAirplaneLength * 2) {
                    console.log('âŒ å¯¹å­æ•°é‡ä¸è¶³');
                    return [];
                }
                
                // é€‰æ‹©æœ€å°çš„å¯¹å­
                const bestPairs = availablePairs.slice(0, currentAirplaneLength * 2);
                
                const playableCombo = [...baseAirplane, ...bestPairs];
                console.log(`âœ… æ‰¾åˆ°å¯å‹é£æœºå¸¦å¯¹: ${playableCombo.map(c => c.value).join(', ')}`);
                return playableCombo;
            }
            
            // å¿«é€ŸæŸ¥æ‰¾æœ€ä½³å‡ºç‰Œç»„åˆï¼ˆä¿ç•™ç”¨äºå…¼å®¹æ€§ï¼‰
            findBestComboFast(cards, playerType) {
                return this.findBestComboInFreePhase(cards);
            }
            
            // ç‚¸å¼¹ä½¿ç”¨å†³ç­–å‡½æ•°
            shouldUseBombNow(bombs, currentCardType, cards, playerType) {
                console.log(`ğŸ’£ ç‚¸å¼¹å†³ç­– - ç‚¸å¼¹æ•°: ${bombs.length}, å½“å‰ç‰Œå‹: ${currentCardType.name}`);
                
                // ç­–ç•¥1ï¼šå½“æ— æ³•ç”¨æ™®é€šç‰Œå‹è¿‡å¯¹æ–¹æ—¶ä½¿ç”¨ç‚¸å¼¹
                const playableCards = this.findPlayableCards(cards, this.currentCards, currentCardType, playerType);
                if (playableCards.length === 0) {
                    console.log('ğŸ’¡ æ— æ³•ç”¨æ™®é€šç‰Œå‹è¿‡ï¼Œè€ƒè™‘ç”¨ç‚¸å¼¹');
                    return true;
                }
                
                // ç­–ç•¥2ï¼šåœ°ä¸»åœ¨å…³é”®æ—¶åˆ»ä½¿ç”¨ç‚¸å¼¹
                if (playerType === 'landlord') {
                    const landlordCards = this.playerCards[this.landlord].length;
                    if (landlordCards < 10 && Math.random() > 0.6) {
                        console.log('ğŸ’¡ åœ°ä¸»ç‰Œå°‘ï¼Œå…³é”®æ—¶åˆ»ä½¿ç”¨ç‚¸å¼¹');
                        return true;
                    }
                }
                
                // ç­–ç•¥3ï¼šå†œæ°‘åœ¨åœ°ä¸»å‡ºå¤§ç‰Œæ—¶ä½¿ç”¨ç‚¸å¼¹
                if (playerType === 'farmer' && this.currentCardsPlayer === this.landlord) {
                    if (currentCardType.name === 'å•ç‰Œ') {
                        const cardRank = this.getValueRank(this.currentCards[0].value);
                        if (cardRank >= this.getValueRank('A')) {
                            console.log('ğŸ’¡ åœ°ä¸»å‡ºå¤§ç‰Œï¼Œå†œæ°‘ç”¨ç‚¸å¼¹æ‹¦æˆª');
                            return true;
                        }
                    }
                }
                
                // ç­–ç•¥4ï¼šé‡åˆ°é•¿é¡ºå­æ—¶ä½¿ç”¨ç‚¸å¼¹
                if (currentCardType.name === 'é¡ºå­' && currentCardType.length > 6) {
                    console.log('ğŸ’¡ é‡åˆ°é•¿é¡ºå­ï¼Œç”¨ç‚¸å¼¹ç‚¸');
                    return true;
                }
                
                return false;
            }
            
            // ç‹ç‚¸ä½¿ç”¨å†³ç­–å‡½æ•°
            shouldUseRoyalBombNow(cards, currentCardType, playerType) {
                console.log(`ğŸ‘‘ ç‹ç‚¸å†³ç­– - å½“å‰ç‰Œå‹: ${currentCardType.name}`);
                
                // ç­–ç•¥1ï¼šåªåœ¨æç«¯æƒ…å†µä¸‹ä½¿ç”¨ç‹ç‚¸
                const totalCards = cards.length;
                if (totalCards <= 5) {
                    console.log('ğŸ’¡ æ‰‹ç‰Œå¾ˆå°‘ï¼Œå…³é”®æ—¶åˆ»ä½¿ç”¨ç‹ç‚¸');
                    return true;
                }
                
                // ç­–ç•¥2ï¼šé‡åˆ°ç‚¸å¼¹æ—¶ä½¿ç”¨ç‹ç‚¸
                if (currentCardType.name === 'ç‚¸å¼¹') {
                    console.log('ğŸ’¡ é‡åˆ°ç‚¸å¼¹ï¼Œç”¨ç‹ç‚¸å‹');
                    return true;
                }
                
                // ç­–ç•¥3ï¼šåœ°ä¸»åœ¨æœ€åé˜¶æ®µä½¿ç”¨ç‹ç‚¸
                if (playerType === 'landlord') {
                    const landlordCards = this.playerCards[this.landlord].length;
                    if (landlordCards <= 3) {
                        console.log('ğŸ’¡ åœ°ä¸»æœ€åé˜¶æ®µï¼Œä½¿ç”¨ç‹ç‚¸');
                        return true;
                    }
                }
                
                return false;
            }
            
            // æŸ¥æ‰¾æœ€ä½³å‡ºç‰Œç»„åˆ - å¢å¼ºç‰ˆ
            findBestCombo(cards, playerType) {
                // ä¼˜å…ˆçº§ï¼šç‚¸å¼¹ > ç‹ç‚¸ > é¡ºå­ > è¿å¯¹ > ä¸‰å¼  > å¯¹å­ > å•ç‰Œ
                
                // 1. æ£€æŸ¥ç‹ç‚¸ - æ™ºèƒ½å†³ç­–
                const hasBigJoker = cards.some(c => c.value === 'big');
                const hasSmallJoker = cards.some(c => c.value === 'small');
                if (hasBigJoker && hasSmallJoker) {
                    const jokerBomb = cards.filter(c => c.value === 'big' || c.value === 'small');
                    // åªæœ‰åœ¨ç‰¹å®šæƒ…å†µä¸‹æ‰å‡ºç‹ç‚¸
                    if (cards.length === 2 || this.shouldUseJokerBomb(cards, playerType)) {
                        return jokerBomb;
                    }
                }
                
                // 2. æ™ºèƒ½ç‚¸å¼¹ç­–ç•¥
                const bombs = this.findBombs(cards);
                if (bombs.length > 0) {
                    // æ™ºèƒ½ç‚¸å¼¹ä½¿ç”¨ç­–ç•¥
                    const bestBomb = this.decideWhenToUseBomb(bombs, cards, playerType);
                    if (bestBomb) {
                        return bestBomb;
                    }
                }
                
                // 3. æ£€æŸ¥é£æœºå¸¦ç¿…è†€
                const airplaneWithSingles = this.findAirplaneWithSingles(cards);
                if (airplaneWithSingles.length > 0) {
                    // ä¼˜å…ˆå‡ºè¾ƒé•¿çš„é£æœºå¸¦ç¿…è†€
                    const longestAirplaneWithSingles = airplaneWithSingles.reduce((a, b) => a.length > b.length ? a : b);
                    if (longestAirplaneWithSingles.length >= 8) { // 2ç»„é£æœºå¸¦ç¿…è†€
                        return longestAirplaneWithSingles;
                    }
                }
                
                // 4. æ£€æŸ¥é£æœº
                const airplanes = this.findAirplanes(cards);
                if (airplanes.length > 0) {
                    // ä¼˜å…ˆå‡ºè¾ƒé•¿çš„é£æœº
                    const longestAirplane = airplanes.reduce((a, b) => a.length > b.length ? a : b);
                    if (longestAirplane.length >= 6) { // 2ç»„é£æœº
                        return longestAirplane;
                    }
                }
                
                // 5. æ£€æŸ¥ä¸‰å¸¦ä¸€å¯¹
                const tripleWithPairs = this.findTripleWithPair(cards);
                if (tripleWithPairs.length > 0) {
                    return tripleWithPairs[0];
                }
                
                // 6. æ£€æŸ¥ä¸‰å¸¦ä¸€
                const tripleWithSingles = this.findTripleWithSingle(cards);
                if (tripleWithSingles.length > 0) {
                    return tripleWithSingles[0];
                }
                
                // 7. æ£€æŸ¥é¡ºå­
                const straights = this.findStraights(cards);
                if (straights.length > 0) {
                    // ä¼˜å…ˆå‡ºè¾ƒé•¿çš„é¡ºå­
                    const longestStraight = straights.reduce((a, b) => a.length > b.length ? a : b);
                    if (longestStraight.length >= 5) {
                        return longestStraight;
                    }
                }
                
                // 8. æ£€æŸ¥è¿å¯¹
                const straightPairs = this.findStraightPairs(cards);
                if (straightPairs.length > 0) {
                    const longestPair = straightPairs.reduce((a, b) => a.length > b.length ? a : b);
                    if (longestPair.length >= 6) { // 3å¯¹
                        return longestPair;
                    }
                }
                
                // 9. æ™ºèƒ½ä¸‰å¼ ç­–ç•¥
                const triples = this.findTriples(cards);
                if (triples.length > 0) {
                    const bestTriple = this.decideBestTriple(triples, cards, playerType);
                    if (bestTriple.length > 0) {
                        return bestTriple;
                    }
                }
                
                // 10. æ™ºèƒ½å¯¹å­ç­–ç•¥
                const pairs = this.findPairs(cards);
                if (pairs.length > 0) {
                    const bestPair = this.decideBestPair(pairs, cards, playerType);
                    if (bestPair.length > 0) {
                        return bestPair;
                    }
                }
                
                // 11. æ™ºèƒ½å•ç‰Œç­–ç•¥
                if (cards.length > 0) {
                    const bestSingle = this.decideBestSingleCard(cards, playerType);
                    if (bestSingle.length > 0) {
                        return bestSingle;
                    }
                    // ä¿åº•ç­–ç•¥
                    return [cards[cards.length - 1]]; // æœ€å°çš„ç‰Œ
                }
                
                return [];
            }
            
            // æŸ¥æ‰¾å¯å‡ºç‰Œ - å¢å¼ºç‰ˆ
            findPlayableCards(cards, currentCards, currentCardType, playerType) {
                const currentValue = currentCardType.rank;
                
                // æ ¹æ®å½“å‰ç‰Œå‹æŸ¥æ‰¾å¯å‡ºçš„ç‰Œ
                switch (currentCardType.name) {
                    case 'å•ç‰Œ':
                        return this.findPlayableSingle(cards, currentValue, playerType);
                    case 'å¯¹å­':
                        return this.findPlayablePair(cards, currentValue, playerType);
                    case 'ä¸‰å¼ ':
                        return this.findPlayableTriple(cards, currentValue);
                    case 'ä¸‰å¸¦ä¸€':
                        return this.findPlayableTripleWithSingle(cards, currentValue);
                    case 'ä¸‰å¸¦ä¸€å¯¹':
                        return this.findPlayableTripleWithPair(cards, currentValue);
                    case 'é¡ºå­':
                        return this.findPlayableStraight(cards, currentValue, currentCardType.length);
                    case 'è¿å¯¹':
                        return this.findPlayableStraightPair(cards, currentValue, currentCardType.length);
                    case 'é£æœº':
                        return this.findPlayableAirplane(cards, currentValue, currentCardType.length);
                    case 'é£æœºå¸¦ç¿…è†€':
                        return this.findPlayableAirplaneWithSingles(cards, currentValue, currentCardType.length);
                    case 'ç‚¸å¼¹':
                        return this.findPlayableBomb(cards, currentValue);
                    case 'ç‹ç‚¸':
                        return []; // ç‹ç‚¸æ— æ³•è¢«å‹
                    default:
                        return [];
                }
            }
            
            // è¾…åŠ©å‡½æ•°ï¼šæŸ¥æ‰¾å¯å‡ºçš„ä¸‰å¸¦ä¸€
            findPlayableTripleWithSingle(cards, currentValue) {
                const tripleWithSingles = this.findTripleWithSingle(cards);
                return tripleWithSingles.find(tws => this.getValueRank(tws[0].value) > currentValue) || [];
            }
            
            // è¾…åŠ©å‡½æ•°ï¼šæŸ¥æ‰¾å¯å‡ºçš„ä¸‰å¸¦ä¸€å¯¹
            findPlayableTripleWithPair(cards, currentValue) {
                const tripleWithPairs = this.findTripleWithPair(cards);
                return tripleWithPairs.find(twp => this.getValueRank(twp[0].value) > currentValue) || [];
            }
            
            // è¾…åŠ©å‡½æ•°ï¼šæŸ¥æ‰¾å¯å‡ºçš„é£æœº
            findPlayableAirplane(cards, currentValue, currentLength) {
                const airplanes = this.findAirplanes(cards);
                return airplanes.find(airplane => 
                    airplane.length === currentLength && 
                    this.getValueRank(airplane[0].value) > currentValue
                ) || [];
            }
            
            // è¾…åŠ©å‡½æ•°ï¼šæŸ¥æ‰¾å¯å‡ºçš„é£æœºå¸¦ç¿…è†€
            findPlayableAirplaneWithSingles(cards, currentValue, currentLength) {
                const airplaneWithSingles = this.findAirplaneWithSingles(cards);
                return airplaneWithSingles.find(aws => 
                    aws.length === currentLength && 
                    this.getValueRank(aws[0].value) > currentValue
                ) || [];
            }
            
            // æ™ºèƒ½ç‚¸å¼¹å†³ç­–
            decideWhenToUseBomb(bombs, cards, playerType) {
                // å¦‚æœåªå‰©ä¸‹ç‚¸å¼¹ï¼Œå¿…é¡»å‡º
                if (cards.length === bombs[0].length) {
                    console.log('ğŸ’£ åªå‰©ç‚¸å¼¹ï¼Œå¿…é¡»å‡º');
                    return bombs[0];
                }
                
                // å¦‚æœæœ‰ç‹ç‚¸ï¼Œç‰¹æ®Šå¤„ç†
                const hasJokerBomb = this.playerCards[this.currentPlayer].some(c => c.suit === 'joker');
                const jokerCount = this.playerCards[this.currentPlayer].filter(c => c.suit === 'joker').length;
                
                // å¦‚æœæœ‰ç‹ç‚¸ä¸”åªæœ‰ç‹ç‚¸å’Œå…¶ä»–ç‚¸å¼¹ï¼Œä¸æ‹†ç‹ç‚¸
                if (hasJokerBomb && jokerCount === 2 && cards.length === bombs[0].length + 2) {
                    console.log('ğŸ‘‘ æœ‰ç‹ç‚¸ï¼Œä¸æ‹†ç‹ç‚¸');
                    return null;
                }
                
                // æ£€æŸ¥å½“å‰å‡ºç‰Œæƒ…å†µ
                if (this.currentCards && this.currentCards.length > 0) {
                    const currentCardType = this.getCardType(this.currentCards);
                    const currentPlayer = this.currentCardsPlayer;
                    
                    // å¦‚æœæ•Œäººå‡ºäº†å¤§ç‰Œä¸”è‡ªå·±æœ‰ç‚¸å¼¹ï¼Œè€ƒè™‘ä½¿ç”¨ç‚¸å¼¹
                    if (currentPlayer !== this.currentPlayer && 
                        currentCardType.rank >= this.getValueRank('A') &&
                        !this.canBeatWithNonBomb(cards, this.currentCards, currentCardType)) {
                        // å†œæ°‘è¦è€ƒè™‘é˜Ÿå‹çš„æƒ…å†µ
                        if (playerType === 'farmer') {
                            // æ£€æŸ¥é˜Ÿå‹æ˜¯å¦è¿˜æœ‰å¾ˆå¤šç‰Œ
                            const teammate = this.getTeammate(this.currentPlayer);
                            const teammateCards = this.playerCards[teammate].length;
                            
                            // å¦‚æœé˜Ÿå‹ç‰Œå¾ˆå°‘ï¼Œå¯èƒ½è®©é˜Ÿå‹å‡ºç‰Œ
                            if (teammateCards <= 3) {
                                console.log('ğŸ¤ é˜Ÿå‹ç‰Œå°‘ï¼Œä¿ç•™ç‚¸å¼¹è®©é˜Ÿå‹å‡ºç‰Œ');
                                return null;
                            }
                        }
                        
                        console.log('ğŸ’£ æ•Œäººå‡ºå¤§ç‰Œï¼Œä½¿ç”¨ç‚¸å¼¹åå‡»');
                        return bombs[0];
                    }
                }
                
                // è‡ªç”±ç‰Œé˜¶æ®µçš„ç‚¸å¼¹ç­–ç•¥
                if (!this.currentCards || this.currentCards.length === 0) {
                    // è‡ªç”±ç‰Œé˜¶æ®µå°½é‡ä¸å‡ºç‚¸å¼¹ï¼Œé™¤éæ˜¯æœ€åå‡ å¼ ç‰Œ
                    if (cards.length > 10) {
                        console.log('â³ è‡ªç”±ç‰Œé˜¶æ®µä¸”ç‰Œè¿˜å¾ˆå¤šï¼Œä¸å‡ºç‚¸å¼¹');
                        return null;
                    }
                    
                    // å¦‚æœæ˜¯åœ°ä¸»ä¸”ç‰Œä¸å¤šäº†ï¼Œå¯ä»¥è€ƒè™‘å‡ºç‚¸å¼¹
                    if (playerType === 'landlord' && cards.length <= 5) {
                        console.log('ğŸ‘‘ åœ°ä¸»ç‰Œå°‘ï¼Œè‡ªç”±ç‰Œé˜¶æ®µå‡ºç‚¸å¼¹');
                        return bombs[0];
                    }
                }
                
                // é¿å…æ‹†å¼€ç‚¸å¼¹
                console.log('ğŸ›¡ï¸  ä¿ç•™ç‚¸å¼¹ï¼Œç­‰å¾…åˆé€‚æ—¶æœº');
                return null;
            }
            
            // æ£€æŸ¥æ˜¯å¦å¯ä»¥ç”¨éç‚¸å¼¹ç‰Œå‹å‡ºç‰Œ
            canBeatWithNonBomb(cards, currentCards, currentCardType) {
                const playableCards = this.findPlayableCards(cards, currentCards, currentCardType, 'landlord');
                return playableCards.length > 0;
            }
            
            // è·å–é˜Ÿå‹
            getTeammate(player) {
                if (this.landlord === player) return null; // åœ°ä¸»æ²¡æœ‰é˜Ÿå‹
                const players = ['left', 'top', 'bottom'];
                return players.find(p => p !== player && p !== this.landlord);
            }

            // æ£€æŸ¥æ•Œäººç‰Œæ•°
            checkEnemyCardCount(minCount, maxCount) {
                const enemies = this.getEnemies(this.currentPlayer);
                return enemies.some(enemy => {
                    const cardCount = this.playerCards[enemy].length;
                    return cardCount >= minCount && cardCount <= maxCount;
                });
            }

            // è·å–æ•Œäººåˆ—è¡¨
            getEnemies(currentPlayer) {
                const enemies = [];
                if (this.landlord === currentPlayer) {
                    // åœ°ä¸»çš„æ•Œäººæ˜¯ä¸¤ä¸ªå†œæ°‘
                    enemies.push(currentPlayer === 'top' ? 'left' : 'top');
                    enemies.push(currentPlayer === 'bottom' ? 'left' : 'bottom');
                } else {
                    // å†œæ°‘çš„æ•Œäººæ˜¯åœ°ä¸»
                    enemies.push(this.landlord);
                }
                return enemies.filter(enemy => enemy !== currentPlayer);
            }

            // æ£€æŸ¥æ˜¯å¦æœ‰ç»å¯¹æœºä¼šï¼ˆå…¨æ–°ç­–ç•¥ï¼‰
            checkAbsoluteChance(cards, valueCounts) {
                // 1. æ£€æŸ¥æ˜¯å¦æœ‰å¤§å°ç‹
                const hasBigJoker = cards.some(c => c.value === 'big');
                const hasSmallJoker = cards.some(c => c.value === 'small');
                
                // 2. æ£€æŸ¥æ˜¯å¦æœ‰ç‚¸å¼¹
                const bombs = this.findBombs(cards);
                
                // 3. æ£€æŸ¥æ˜¯å¦æœ‰6å¼ ä»¥ä¸Šçš„å¤§ç»„åˆ
                const bigCombos = this.findBigCombinations(cards, valueCounts);
                
                // ç»¼åˆåˆ¤æ–­ï¼šéœ€è¦å¤§å°ç‹æˆ–ç‚¸å¼¹ + å¤§ç»„åˆ
                const hasPowerCards = hasBigJoker || hasSmallJoker || bombs.length > 0;
                
                return hasPowerCards && bigCombos.length > 0;
            }
            
            // æŸ¥æ‰¾6å¼ ä»¥ä¸Šçš„å¤§ç»„åˆ
            findBigCombinations(cards, valueCounts) {
                const bigCombos = [];
                
                // æ£€æŸ¥é¡ºå­ï¼ˆ6å¼ ä»¥ä¸Šï¼‰
                const straights = this.findStraights(cards).filter(s => s.length >= 6);
                bigCombos.push(...straights);
                
                // æ£€æŸ¥è¿å¯¹ï¼ˆ6å¼ ä»¥ä¸Šï¼Œ3å¯¹ï¼‰
                const straightPairs = this.findStraightPairs(cards).filter(s => s.length >= 6);
                bigCombos.push(...straightPairs);
                
                // æ£€æŸ¥é£æœºï¼ˆ6å¼ ä»¥ä¸Šï¼‰
                const airplanes = this.findAirplanes(cards, valueCounts).filter(s => s.length >= 6);
                bigCombos.push(...airplanes);
                
                // æ£€æŸ¥é£æœºå¸¦ç¿…è†€ï¼ˆ6å¼ ä»¥ä¸Šï¼‰
                const airplaneWithWings = this.findAirplaneWithWings(cards, valueCounts).filter(s => s.length >= 6);
                bigCombos.push(...airplaneWithWings);
                
                return bigCombos;
            }
            
            // è®¡ç®—å­—æ¯ç‰Œæ•°é‡
            countLetterCards(cards) {
                const letterValues = ['J', 'Q', 'K', 'A', '2', 'small', 'big'];
                return cards.filter(card => letterValues.includes(card.value)).length;
            }
            
            // å¯»æ‰¾å¯ä»¥ä¸¢å¼ƒçš„æ‚ç‰Œ
            findTrashCardToPlay(cards, valueCounts) {
                // å¤åˆ¶å¹¶æ’åº
                const sortedCards = [...cards].sort((a, b) => this.getValueRank(a.value) - this.getValueRank(b.value));
                
                // ä¼˜å…ˆä¸¢å¼ƒå°å•ç‰Œï¼ˆ3-10ï¼‰
                const smallSingles = sortedCards.filter(card => {
                    const value = card.value;
                    const count = valueCounts[value];
                    const rank = this.getValueRank(value);
                    // å°ç‰Œï¼ˆ3-10ï¼‰ä¸”æ˜¯å•å¼ 
                    return count === 1 && rank >= this.getValueRank('3') && rank <= this.getValueRank('10');
                });
                
                if (smallSingles.length > 0) {
                    return smallSingles[0]; // è¿”å›æœ€å°çš„å°å•ç‰Œ
                }
                
                // å¦‚æœæ²¡æœ‰å°å•ç‰Œï¼Œå¯»æ‰¾å¯ä»¥æ‹†çš„å¯¹å­ä¸­çš„å°ç‰Œ
                const smallPairs = sortedCards.filter(card => {
                    const value = card.value;
                    const count = valueCounts[value];
                    const rank = this.getValueRank(value);
                    // å°å¯¹å­ï¼ˆ3-Jï¼‰ä¸”ä¸æ˜¯ç‚¸å¼¹ææ–™
                    return count === 2 && rank <= this.getValueRank('J') && value !== '2' && value !== 'A';
                });
                
                if (smallPairs.length > 0) {
                    return smallPairs[0]; // è¿”å›æœ€å°çš„å°å¯¹å­ä¸­çš„ä¸€å¼ 
                }
                
                return null; // æ²¡æœ‰åˆé€‚çš„æ‚ç‰Œå¯å‡º
            }
            
            // åˆ¤æ–­æ˜¯å¦åº”è¯¥ä½¿ç”¨ç‹ç‚¸
            shouldUseJokerBomb(cards, playerType) {
                // å¦‚æœåªå‰©ä¸‹ç‹ç‚¸ï¼Œå¿…é¡»å‡º
                if (cards.length === 2) {
                    return true;
                }
                
                // å¼€å±€é˜¶æ®µï¼ˆæ‰‹ç‰Œå¤šï¼‰ï¼šç»å¯¹ä¸å‡ºç‹ç‚¸
                if (cards.length >= 15) {
                    console.log('ğŸ‘‘ å¼€å±€é˜¶æ®µä¸å‡ºç‹ç‚¸');
                    return false;
                }
                
                // ä¸­æœŸé˜¶æ®µï¼šè°¨æ…ä½¿ç”¨ç‹ç‚¸
                if (cards.length > 8) {
                    // åªæœ‰åœ¨ç‰¹å®šç´§æ€¥æƒ…å†µä¸‹æ‰è€ƒè™‘å‡ºç‹ç‚¸
                    // æ£€æŸ¥æ˜¯å¦æœ‰æ•Œäººå³å°†è·èƒœ
                    const enemies = playerType === 'landlord' ? 
                        ['left', 'top'].filter(p => p !== this.currentPlayer) : 
                        [this.landlord];
                    
                    const enemyCardCounts = enemies.map(e => this.playerCards[e].length);
                    const minEnemyCards = Math.min(...enemyCardCounts);
                    
                    // å¦‚æœæ•Œäººåªå‰©1-2å¼ ç‰Œï¼Œä¸”è‡ªå·±æœ‰ç‹ç‚¸ï¼Œå¯ä»¥è€ƒè™‘ä½¿ç”¨
                    if (minEnemyCards <= 2 && Math.random() > 0.7) {
                        console.log('ğŸš¨ æ•Œäººå³å°†è·èƒœï¼Œè€ƒè™‘ä½¿ç”¨ç‹ç‚¸');
                        return true;
                    }
                    
                    return false;
                }
                
                // åæœŸé˜¶æ®µï¼šå¯ä»¥è€ƒè™‘ä½¿ç”¨ç‹ç‚¸
                if (cards.length <= 8) {
                    // åœ°ä¸»ï¼šå¦‚æœç‰Œå°‘ä¸”æœ‰æœºä¼šç›´æ¥è·èƒœ
                    if (playerType === 'landlord') {
                        // å¦‚æœä½¿ç”¨ç‹ç‚¸ååªå‰©å°‘é‡ç‰Œï¼Œå¯ä»¥è€ƒè™‘
                        const remainingCards = cards.length - 2;
                        if (remainingCards <= 3) {
                            console.log('ğŸ‘‘ åœ°ä¸»åæœŸä½¿ç”¨ç‹ç‚¸');
                            return true;
                        }
                    }
                    
                    // å†œæ°‘ï¼šå¦‚æœé˜Ÿå‹ç‰Œå°‘ï¼Œå°½é‡ä¿ç•™ç‹ç‚¸
                    if (playerType === 'farmer') {
                        const teammate = this.getTeammate(this.currentPlayer);
                        if (teammate && this.playerCards[teammate].length <= 3) {
                            console.log('ğŸ¤ é˜Ÿå‹ç‰Œå°‘ï¼Œä¿ç•™ç‹ç‚¸');
                            return false;
                        }
                    }
                    
                    // åæœŸé˜¶æ®µæœ‰ä¸€å®šæ¦‚ç‡ä½¿ç”¨ç‹ç‚¸
                    return Math.random() > 0.6;
                }
                
                return false;
            }
            
            // æ™ºèƒ½å•ç‰Œå†³ç­–
            decideBestSingleCard(cards, playerType) {
                // æŒ‰ç‰Œå€¼ä»å¤§åˆ°å°æ’åº
                const sortedCards = [...cards].sort((a, b) => this.getValueRank(b.value) - this.getValueRank(a.value));
                const reverseSorted = [...cards].sort((a, b) => this.getValueRank(a.value) - this.getValueRank(b.value));
                
                // è·å–å„ç§ç‰Œçš„åˆ†ç»„
                const bigCards = sortedCards.filter(c => ['2', 'A', 'K', 'Q', 'J'].includes(c.value));
                const mediumCards = sortedCards.filter(c => ['10', '9', '8', '7', '6', '5'].includes(c.value));
                const smallCards = sortedCards.filter(c => ['4', '3'].includes(c.value));
                
                // æ£€æŸ¥æ•Œäººçš„ç‰Œæ•°
                const enemies = playerType === 'landlord' ? 
                    ['left', 'top'].filter(p => p !== this.currentPlayer) : 
                    [this.landlord];
                
                const enemyCardCounts = enemies.map(e => this.playerCards[e].length);
                const minEnemyCards = Math.min(...enemyCardCounts);
                const hasLowEnemyCards = minEnemyCards <= 3;
                
                // æ£€æŸ¥æ˜¯å¦æœ‰ä¸‰å¼ çš„å°ç‰Œ
                const tripleSmallCards = smallCards.filter(c => {
                    const count = cards.filter(c2 => c2.value === c.value).length;
                    return count >= 3;
                });
                
                // ç­–ç•¥1ï¼šå¦‚æœæœ‰å°ç‰Œä¸”ä¸æ˜¯ä¸‰å¼ ï¼Œå°½å¿«å‡ºæ‰
                if (smallCards.length > 0 && tripleSmallCards.length === 0) {
                    console.log('ğŸƒ ä¼˜å…ˆå‡ºå°ç‰Œ:', smallCards[smallCards.length - 1].value);
                    return [smallCards[smallCards.length - 1]];
                }
                
                // ç­–ç•¥2ï¼šå¦‚æœæ•Œäººç‰Œå¾ˆå°‘ï¼Œè€ƒè™‘å‡ºå¤§ç‰Œå‹åˆ¶
                if (hasLowEnemyCards) {
                    if (bigCards.length > 0) {
                        console.log('ğŸš¨ æ•Œäººç‰Œå°‘ï¼Œå‡ºå¤§ç‰Œå‹åˆ¶:', bigCards[0].value);
                        return [bigCards[0]];
                    }
                }
                
                // ç­–ç•¥3ï¼šå†œæ°‘ä¿ç•™å¤§ç‰Œï¼Œåœ°ä¸»æ ¹æ®æƒ…å†µ
                if (playerType === 'farmer') {
                    // å†œæ°‘å°½é‡ä¿ç•™2å’ŒA
                    const nonBigCards = sortedCards.filter(c => !['2', 'A'].includes(c.value));
                    if (nonBigCards.length > 0) {
                        // ä»å¤§åˆ°å°é€‰æ‹©åˆé€‚çš„ç‰Œ
                        for (let card of nonBigCards) {
                            // å¦‚æœè¿™å¼ ç‰Œæ²¡æœ‰å½¢æˆå¯¹å­æˆ–ä¸‰å¼ ï¼Œä¼˜å…ˆå‡º
                            const count = cards.filter(c2 => c2.value === card.value).length;
                            if (count === 1) {
                                console.log('ğŸ‘¨â€ğŸŒ¾ å†œæ°‘ä¿ç•™å¤§ç‰Œï¼Œå‡ºå•ç‰Œ:', card.value);
                                return [card];
                            }
                        }
                        // å¦‚æœéƒ½æ˜¯å¯¹å­æˆ–ä¸‰å¼ ï¼Œå‡ºæœ€å°çš„
                        return [nonBigCards[nonBigCards.length - 1]];
                    }
                }
                
                // ç­–ç•¥4ï¼šåœ°ä¸»çš„ç­–ç•¥ - ä¸¥æ ¼æ§åˆ¶å¤§ç‰Œä½¿ç”¨
                if (playerType === 'landlord') {
                    // å¼€å±€é˜¶æ®µï¼ˆæ‰‹ç‰Œæ•°é‡å¤šï¼‰ï¼šä¸¥æ ¼è¦æ±‚å‡ºå°ç‰Œ
                    if (cards.length >= 15) {
                        // å¼€å±€é˜¶æ®µå¿…é¡»å‡ºæœ€å°çš„ç‰Œ
                        if (smallCards.length > 0) {
                            console.log('ğŸ‘‘ åœ°ä¸»å¼€å±€é˜¶æ®µï¼Œä¸¥æ ¼å‡ºå°ç‰Œ:', smallCards[smallCards.length - 1].value);
                            return [smallCards[smallCards.length - 1]];
                        }
                        if (mediumCards.length > 0) {
                            console.log('ğŸ‘‘ åœ°ä¸»å¼€å±€é˜¶æ®µï¼Œå‡ºä¸­ç­‰ç‰Œ:', mediumCards[mediumCards.length - 1].value);
                            return [mediumCards[mediumCards.length - 1]];
                        }
                        // å¦‚æœæ²¡æœ‰å°ç‰Œå’Œä¸­ç­‰ç‰Œï¼Œæ‰è€ƒè™‘å¤§ç‰Œ
                        if (bigCards.length > 0) {
                            console.log('ğŸ‘‘ åœ°ä¸»å¼€å±€é˜¶æ®µï¼Œè¢«è¿«å‡ºå¤§ç‰Œ:', bigCards[bigCards.length - 1].value);
                            return [bigCards[bigCards.length - 1]]; // å‡ºæœ€å°çš„å¤§ç‰Œ
                        }
                    } else if (cards.length > 8) {
                        // ä¸­æœŸé˜¶æ®µï¼šä¼˜å…ˆå‡ºå°ç‰Œ
                        if (smallCards.length > 0) {
                            console.log('ğŸ‘‘ åœ°ä¸»ä¸­æœŸé˜¶æ®µï¼Œä¼˜å…ˆå‡ºå°ç‰Œ:', smallCards[smallCards.length - 1].value);
                            return [smallCards[smallCards.length - 1]];
                        }
                        if (mediumCards.length > 0) {
                            console.log('ğŸ‘‘ åœ°ä¸»ä¸­æœŸé˜¶æ®µï¼Œå‡ºä¸­ç­‰ç‰Œ:', mediumCards[mediumCards.length - 1].value);
                            return [mediumCards[mediumCards.length - 1]];
                        }
                    } else {
                        // åæœŸé˜¶æ®µï¼ˆç‰Œå°‘çš„æ—¶å€™ï¼‰ï¼šå‡ºå¤§ç‰Œæ§åˆ¶å±€é¢
                        if (bigCards.length > 0) {
                            console.log('ğŸ‘‘ åœ°ä¸»åæœŸé˜¶æ®µï¼Œå‡ºå¤§ç‰Œæ§åˆ¶:', bigCards[0].value);
                            return [bigCards[0]];
                        }
                    }
                }
                
                // ç­–ç•¥5ï¼šä¿åº•ç­–ç•¥ï¼Œå‡ºæœ€å°çš„ç‰Œ
                const smallestCard = reverseSorted[0];
                console.log('ğŸ“Š ä¿åº•ç­–ç•¥ï¼Œå‡ºæœ€å°ç‰Œ:', smallestCard.value);
                return [smallestCard];
            }
            
            // æ™ºèƒ½å¯¹å­å†³ç­–
            decideBestPair(pairs, cards, playerType) {
                // æŒ‰ç‰Œå€¼ä»å¤§åˆ°å°æ’åºå¯¹å­
                const sortedPairs = [...pairs].sort((a, b) => this.getValueRank(b[0].value) - this.getValueRank(a[0].value));
                
                // åˆ†ç±»å¯¹å­
                const bigPairs = sortedPairs.filter(p => ['2', 'A', 'K'].includes(p[0].value));
                const mediumPairs = sortedPairs.filter(p => ['Q', 'J', '10', '9', '8'].includes(p[0].value));
                const smallPairs = sortedPairs.filter(p => ['7', '6', '5', '4', '3'].includes(p[0].value));
                
                // æ£€æŸ¥æ˜¯å¦å¯ä»¥å½¢æˆä¸‰å¼ 
                const canFormTriple = (pairValue) => {
                    const count = cards.filter(c => c.value === pairValue).length;
                    return count >= 3;
                };
                
                // å†œæ°‘ç­–ç•¥
                if (playerType === 'farmer') {
                    // å†œæ°‘ä¿ç•™å¤§ç‰Œå¯¹å­
                    const nonBigPairs = sortedPairs.filter(p => !['2', 'A'].includes(p[0].value));
                    if (nonBigPairs.length > 0) {
                        // ä¼˜å…ˆå‡ºä¸èƒ½å½¢æˆä¸‰å¼ çš„å¯¹å­
                        for (let pair of nonBigPairs) {
                            if (!canFormTriple(pair[0].value)) {
                                console.log('ğŸ‘¨â€ğŸŒ¾ å†œæ°‘å‡ºéå¤§ç‰Œå¯¹å­:', pair[0].value);
                                return pair;
                            }
                        }
                        // å¦‚æœéƒ½æ˜¯å¯ä»¥å½¢æˆä¸‰å¼ çš„ï¼Œå‡ºæœ€å°çš„
                        return nonBigPairs[nonBigPairs.length - 1];
                    }
                }
                
                // åœ°ä¸»ç­–ç•¥
                if (playerType === 'landlord') {
                    // å¼€å±€é˜¶æ®µï¼ˆæ‰‹ç‰Œå¤šï¼‰ï¼šä¸å‡ºå¤§ç‰Œå¯¹å­
                    if (cards.length >= 15) {
                        if (smallPairs.length > 0) {
                            // ä¼˜å…ˆå‡ºä¸èƒ½å½¢æˆä¸‰å¼ çš„å°å¯¹å­
                            const playableSmallPairs = smallPairs.filter(p => !canFormTriple(p[0].value));
                            if (playableSmallPairs.length > 0) {
                                console.log('ğŸ‘‘ åœ°ä¸»å¼€å±€å‡ºå°å¯¹å­:', playableSmallPairs[0][0].value);
                                return playableSmallPairs[0];
                            }
                            // å¦‚æœéƒ½æ˜¯å¯ä»¥å½¢æˆä¸‰å¼ çš„ï¼Œé€‰æ‹©æœ€å°çš„
                            console.log('ğŸ‘‘ åœ°ä¸»å¼€å±€å‡ºå°å¯¹å­:', smallPairs[smallPairs.length - 1][0].value);
                            return smallPairs[smallPairs.length - 1];
                        }
                        if (mediumPairs.length > 0) {
                            console.log('ğŸ‘‘ åœ°ä¸»å¼€å±€å‡ºä¸­ç­‰å¯¹å­:', mediumPairs[mediumPairs.length - 1][0].value);
                            return mediumPairs[mediumPairs.length - 1];
                        }
                        // å¼€å±€é˜¶æ®µå°½é‡ä¸å‡ºå¤§ç‰Œå¯¹å­
                        if (bigPairs.length > 0) {
                            console.log('ğŸ‘‘ åœ°ä¸»å¼€å±€é¿å…å‡ºå¤§ç‰Œå¯¹å­ï¼Œé€‰æ‹©å…¶ä»–ç‰Œå‹');
                            return [];
                        }
                    } else if (cards.length > 8) {
                        // ä¸­æœŸé˜¶æ®µï¼šè°¨æ…å‡ºå¤§ç‰Œå¯¹å­
                        if (smallPairs.length > 0) {
                            console.log('ğŸ‘‘ åœ°ä¸»ä¸­æœŸå‡ºå°å¯¹å­:', smallPairs[0][0].value);
                            return smallPairs[0];
                        }
                        if (mediumPairs.length > 0) {
                            console.log('ğŸ‘‘ åœ°ä¸»ä¸­æœŸå‡ºä¸­ç­‰å¯¹å­:', mediumPairs[0][0].value);
                            return mediumPairs[0];
                        }
                    } else {
                        // åæœŸé˜¶æ®µï¼šå¯ä»¥å‡ºå¤§ç‰Œå¯¹å­
                        if (bigPairs.length > 0) {
                            console.log('ğŸ‘‘ åœ°ä¸»åæœŸå‡ºå¤§ç‰Œå¯¹å­:', bigPairs[0][0].value);
                            return bigPairs[0];
                        }
                    }
                }
                
                // ä¿åº•ç­–ç•¥ï¼šå‡ºæœ€å°çš„å¯¹å­
                if (sortedPairs.length > 0) {
                    const smallestPair = sortedPairs[sortedPairs.length - 1];
                    console.log('ğŸ“Š ä¿åº•ç­–ç•¥ï¼Œå‡ºæœ€å°å¯¹å­:', smallestPair[0].value);
                    return smallestPair;
                }
                
                return [];
            }
            
            // æ™ºèƒ½ä¸‰å¼ å†³ç­–
            decideBestTriple(triples, cards, playerType) {
                // æŒ‰ç‰Œå€¼ä»å¤§åˆ°å°æ’åºä¸‰å¼ 
                const sortedTriples = [...triples].sort((a, b) => this.getValueRank(b[0].value) - this.getValueRank(a[0].value));
                
                // åˆ†ç±»ä¸‰å¼ 
                const bigTriples = sortedTriples.filter(t => ['2', 'A'].includes(t[0].value));
                const mediumTriples = sortedTriples.filter(t => ['K', 'Q', 'J', '10'].includes(t[0].value));
                const smallTriples = sortedTriples.filter(t => ['9', '8', '7', '6', '5', '4', '3'].includes(t[0].value));
                
                // æ£€æŸ¥æ˜¯å¦å¯ä»¥å½¢æˆä¸‰å¸¦ä¸€æˆ–ä¸‰å¸¦ä¸€å¯¹
                const canFormTripleWithSingle = (tripleValue) => {
                    const availableSingles = cards.filter(c => 
                        c.value !== tripleValue && 
                        cards.filter(c2 => c2.value === c.value).length === 1
                    );
                    return availableSingles.length > 0;
                };
                
                const canFormTripleWithPair = (tripleValue) => {
                    const availablePairs = cards.filter(c => 
                        c.value !== tripleValue && 
                        cards.filter(c2 => c2.value === c.value).length >= 2
                    );
                    return availablePairs.length >= 2;
                };
                
                // æ£€æŸ¥æ˜¯å¦åªå‰©è¿™ä¸‰å¼ ç‰Œ
                const isLastCards = (triple) => cards.length === triple.length;
                
                // å†œæ°‘ç­–ç•¥
                if (playerType === 'farmer') {
                    // å†œæ°‘ä¿ç•™å¤§ç‰Œä¸‰å¼ 
                    const nonBigTriples = sortedTriples.filter(t => !['2', 'A'].includes(t[0].value));
                    if (nonBigTriples.length > 0) {
                        // ä¼˜å…ˆå‡ºå°çš„ä¸‰å¼ 
                        const bestTriple = nonBigTriples[nonBigTriples.length - 1];
                        console.log('ğŸ‘¨â€ğŸŒ¾ å†œæ°‘å‡ºå°ä¸‰å¼ :', bestTriple[0].value);
                        return bestTriple;
                    }
                    // å¦‚æœåªæœ‰å¤§ç‰Œä¸‰å¼ ï¼Œæ£€æŸ¥æ˜¯å¦å¯ä»¥ä¸€æ¬¡æ€§å‡ºå®Œ
                    if (bigTriples.length > 0) {
                        const bigTriple = bigTriples[0];
                        if (isLastCards(bigTriple) || canFormTripleWithSingle(bigTriple[0].value) || canFormTripleWithPair(bigTriple[0].value)) {
                            console.log('ğŸ‘¨â€ğŸŒ¾ å†œæ°‘å‡ºå¤§ç‰Œä¸‰å¼ :', bigTriple[0].value);
                            return bigTriple;
                        }
                        // å¦åˆ™ä¿ç•™å¤§ç‰Œä¸‰å¼ 
                        console.log('ğŸ‘¨â€ğŸŒ¾ å†œæ°‘ä¿ç•™å¤§ç‰Œä¸‰å¼ ');
                        return [];
                    }
                }
                
                // åœ°ä¸»ç­–ç•¥
                if (playerType === 'landlord') {
                    // å¼€å±€é˜¶æ®µï¼šè°¨æ…å‡ºå¤§ç‰Œä¸‰å¼ 
                    if (cards.length >= 15) {
                        if (smallTriples.length > 0) {
                            console.log('ğŸ‘‘ åœ°ä¸»å¼€å±€å‡ºå°ä¸‰å¼ :', smallTriples[0][0].value);
                            return smallTriples[0];
                        }
                        if (mediumTriples.length > 0) {
                            console.log('ğŸ‘‘ åœ°ä¸»å¼€å±€å‡ºä¸­ç­‰ä¸‰å¼ :', mediumTriples[0][0].value);
                            return mediumTriples[0];
                        }
                        // å¼€å±€é˜¶æ®µå°½é‡ä¸å‡ºå¤§ç‰Œä¸‰å¼ 
                        if (bigTriples.length > 0) {
                            console.log('ğŸ‘‘ åœ°ä¸»å¼€å±€é¿å…å‡ºå¤§ç‰Œä¸‰å¼ ï¼Œé€‰æ‹©å…¶ä»–ç‰Œå‹');
                            return [];
                        }
                    } else if (cards.length > 8) {
                        // ä¸­æœŸé˜¶æ®µï¼šå¯ä»¥å‡ºä¸­ç­‰ä¸‰å¼ 
                        if (smallTriples.length > 0) {
                            console.log('ğŸ‘‘ åœ°ä¸»ä¸­æœŸå‡ºå°ä¸‰å¼ :', smallTriples[0][0].value);
                            return smallTriples[0];
                        }
                        if (mediumTriples.length > 0) {
                            console.log('ğŸ‘‘ åœ°ä¸»ä¸­æœŸå‡ºä¸­ç­‰ä¸‰å¼ :', mediumTriples[0][0].value);
                            return mediumTriples[0];
                        }
                        // ä¸­æœŸé˜¶æ®µè°¨æ…å‡ºå¤§ç‰Œä¸‰å¼ 
                        if (bigTriples.length > 0) {
                            const bigTriple = bigTriples[0];
                            if (canFormTripleWithSingle(bigTriple[0].value) || canFormTripleWithPair(bigTriple[0].value)) {
                                console.log('ğŸ‘‘ åœ°ä¸»ä¸­æœŸå‡ºå¤§ç‰Œä¸‰å¸¦:', bigTriple[0].value);
                                return bigTriple;
                            }
                        }
                    } else {
                        // åæœŸé˜¶æ®µï¼šå¯ä»¥å‡ºå¤§ç‰Œä¸‰å¼ 
                        if (bigTriples.length > 0) {
                            console.log('ğŸ‘‘ åœ°ä¸»åæœŸå‡ºå¤§ç‰Œä¸‰å¼ :', bigTriples[0][0].value);
                            return bigTriples[0];
                        }
                        if (mediumTriples.length > 0) {
                            console.log('ğŸ‘‘ åœ°ä¸»åæœŸå‡ºä¸­ç­‰ä¸‰å¼ :', mediumTriples[0][0].value);
                            return mediumTriples[0];
                        }
                        if (smallTriples.length > 0) {
                            console.log('ğŸ‘‘ åœ°ä¸»åæœŸå‡ºå°ä¸‰å¼ :', smallTriples[0][0].value);
                            return smallTriples[0];
                        }
                    }
                }
                
                // ä¿åº•ç­–ç•¥ï¼šå‡ºæœ€å°çš„ä¸‰å¼ 
                if (sortedTriples.length > 0) {
                    const smallestTriple = sortedTriples[sortedTriples.length - 1];
                    console.log('ğŸ“Š ä¿åº•ç­–ç•¥ï¼Œå‡ºæœ€å°ä¸‰å¼ :', smallestTriple[0].value);
                    return smallestTriple;
                }
                
                return [];
            }
            
            // è¾…åŠ©å‡½æ•°ï¼šæŸ¥æ‰¾ç‚¸å¼¹
            findBombs(cards) {
                const valueCount = {};
                cards.forEach(card => {
                    valueCount[card.value] = (valueCount[card.value] || 0) + 1;
                });
                
                const bombs = [];
                Object.keys(valueCount).forEach(value => {
                    if (valueCount[value] === 4) {
                        bombs.push(cards.filter(c => c.value === value));
                    }
                });
                
                // æŒ‰å¤§å°æ’åº
                return bombs.sort((a, b) => this.getValueRank(b[0].value) - this.getValueRank(a[0].value));
            }
            
            // è¾…åŠ©å‡½æ•°ï¼šæŸ¥æ‰¾é¡ºå­
            findStraights(cards) {
                const values = [...new Set(cards.map(c => c.value))]
                    .filter(v => v !== 'small' && v !== 'big')
                    .sort((a, b) => this.getValueRank(b) - this.getValueRank(a));
                
                const straights = [];
                let currentStraight = [values[0]];
                
                for (let i = 1; i < values.length; i++) {
                    if (this.getValueRank(values[i]) === this.getValueRank(currentStraight[currentStraight.length - 1]) - 1) {
                        currentStraight.push(values[i]);
                    } else {
                        if (currentStraight.length >= 5) {
                            straights.push(currentStraight);
                        }
                        currentStraight = [values[i]];
                    }
                }
                
                if (currentStraight.length >= 5) {
                    straights.push(currentStraight);
                }
                
                // è½¬æ¢ä¸ºå®é™…å¡ç‰Œ
                return straights.map(straight => {
                    return straight.map(value => cards.find(c => c.value === value)).filter(Boolean);
                });
            }
            
            // è¾…åŠ©å‡½æ•°ï¼šæŸ¥æ‰¾å¯¹å­
            findPairs(cards) {
                const valueCount = {};
                cards.forEach(card => {
                    valueCount[card.value] = (valueCount[card.value] || 0) + 1;
                });
                
                const pairs = [];
                Object.keys(valueCount).forEach(value => {
                    if (valueCount[value] >= 2) {
                        const pair = cards.filter(c => c.value === value).slice(0, 2);
                        pairs.push(pair);
                    }
                });
                
                return pairs.sort((a, b) => this.getValueRank(b[0].value) - this.getValueRank(a[0].value));
            }
            
            // è¾…åŠ©å‡½æ•°ï¼šæŸ¥æ‰¾ä¸‰å¼ 
            findTriples(cards) {
                const valueCount = {};
                cards.forEach(card => {
                    valueCount[card.value] = (valueCount[card.value] || 0) + 1;
                });
                
                const triples = [];
                Object.keys(valueCount).forEach(value => {
                    if (valueCount[value] >= 3) {
                        const triple = cards.filter(c => c.value === value).slice(0, 3);
                        triples.push(triple);
                    }
                });
                
                return triples.sort((a, b) => this.getValueRank(b[0].value) - this.getValueRank(a[0].value));
            }
            
            // è¾…åŠ©å‡½æ•°ï¼šæŸ¥æ‰¾è¿å¯¹
            findStraightPairs(cards) {
                const pairs = this.findPairs(cards);
                if (pairs.length < 2) return [];
                
                const pairValues = pairs.map(p => p[0].value).sort((a, b) => this.getValueRank(b) - this.getValueRank(a));
                const straightPairs = [];
                let currentStraight = [pairValues[0]];
                
                for (let i = 1; i < pairValues.length; i++) {
                    if (this.getValueRank(pairValues[i]) === this.getValueRank(currentStraight[currentStraight.length - 1]) - 1) {
                        currentStraight.push(pairValues[i]);
                    } else {
                        if (currentStraight.length >= 2) {
                            straightPairs.push(currentStraight);
                        }
                        currentStraight = [pairValues[i]];
                    }
                }
                
                if (currentStraight.length >= 2) {
                    straightPairs.push(currentStraight);
                }
                
                // è½¬æ¢ä¸ºå®é™…å¡ç‰Œ
                return straightPairs.map(straight => {
                    return straight.flatMap(value => pairs.find(p => p[0].value === value));
                });
            }
            
            // è¾…åŠ©å‡½æ•°ï¼šæŸ¥æ‰¾ä¸‰å¸¦ä¸€
            findTripleWithSingle(cards) {
                const triples = this.findTriples(cards);
                if (triples.length === 0) return [];
                
                const tripleWithSingles = [];
                const usedValues = new Set();
                
                triples.forEach(triple => {
                    const tripleValue = triple[0].value;
                    usedValues.add(tripleValue);
                    
                    // æŸ¥æ‰¾å¯ç”¨çš„å•ç‰Œ
                    const availableSingles = cards.filter(c => 
                        c.value !== tripleValue && 
                        !usedValues.has(c.value) &&
                        cards.filter(c2 => c2.value === c.value).length === 1
                    );
                    
                    if (availableSingles.length > 0) {
                        // é€‰æ‹©æœ€å°çš„å•ç‰Œ
                        const single = availableSingles.reduce((a, b) => 
                            this.getValueRank(a.value) < this.getValueRank(b.value) ? a : b
                        );
                        tripleWithSingles.push([...triple, single]);
                        usedValues.add(single.value);
                    }
                });
                
                return tripleWithSingles.sort((a, b) => this.getValueRank(b[0].value) - this.getValueRank(a[0].value));
            }
            
            // è¾…åŠ©å‡½æ•°ï¼šæŸ¥æ‰¾ä¸‰å¸¦ä¸€å¯¹
            findTripleWithPair(cards) {
                const triples = this.findTriples(cards);
                const pairs = this.findPairs(cards);
                if (triples.length === 0 || pairs.length === 0) return [];
                
                const tripleWithPairs = [];
                
                triples.forEach(triple => {
                    const tripleValue = triple[0].value;
                    
                    // æŸ¥æ‰¾å¯ç”¨çš„å¯¹å­ï¼ˆä¸èƒ½ä¸ä¸‰å¼ çš„æ•°å€¼ç›¸åŒï¼‰
                    const availablePairs = pairs.filter(pair => pair[0].value !== tripleValue);
                    
                    if (availablePairs.length > 0) {
                        // é€‰æ‹©æœ€å°çš„å¯¹å­
                        const pair = availablePairs.reduce((a, b) => 
                            this.getValueRank(a[0].value) < this.getValueRank(b[0].value) ? a : b
                        );
                        tripleWithPairs.push([...triple, ...pair]);
                    }
                });
                
                return tripleWithPairs.sort((a, b) => this.getValueRank(b[0].value) - this.getValueRank(a[0].value));
            }
            
            // è¾…åŠ©å‡½æ•°ï¼šæŸ¥æ‰¾é£æœºï¼ˆè¿ä¸‰å¼ ï¼‰
            findAirplanes(cards) {
                const triples = this.findTriples(cards);
                if (triples.length < 2) return [];
                
                const tripleValues = triples.map(t => t[0].value).sort((a, b) => this.getValueRank(b) - this.getValueRank(a));
                const airplanes = [];
                let currentAirplane = [tripleValues[0]];
                
                for (let i = 1; i < tripleValues.length; i++) {
                    if (this.getValueRank(tripleValues[i]) === this.getValueRank(currentAirplane[currentAirplane.length - 1]) - 1) {
                        currentAirplane.push(tripleValues[i]);
                    } else {
                        if (currentAirplane.length >= 2) {
                            airplanes.push(currentAirplane);
                        }
                        currentAirplane = [tripleValues[i]];
                    }
                }
                
                if (currentAirplane.length >= 2) {
                    airplanes.push(currentAirplane);
                }
                
                // è½¬æ¢ä¸ºå®é™…å¡ç‰Œ
                return airplanes.map(airplane => {
                    return airplane.flatMap(value => triples.find(t => t[0].value === value));
                });
            }
            
            // è¾…åŠ©å‡½æ•°ï¼šæŸ¥æ‰¾é£æœºå¸¦ç¿…è†€ï¼ˆé£æœºå¸¦å•ç‰Œï¼‰
            findAirplaneWithSingles(cards) {
                const airplanes = this.findAirplanes(cards);
                if (airplanes.length === 0) return [];
                
                const airplaneWithSingles = [];
                
                airplanes.forEach(airplane => {
                    const airplaneValues = new Set(airplane.map(c => c.value));
                    const requiredSingles = airplane.length / 3; // æ¯3å¼ éœ€è¦1å¼ å•ç‰Œ
                    
                    // æŸ¥æ‰¾å¯ç”¨çš„å•ç‰Œ
                    const availableSingles = cards.filter(c => 
                        !airplaneValues.has(c.value) &&
                        cards.filter(c2 => c2.value === c.value).length === 1
                    );
                    
                    if (availableSingles.length >= requiredSingles) {
                        // é€‰æ‹©æœ€å°çš„å•ç‰Œ
                        const singles = availableSingles
                            .sort((a, b) => this.getValueRank(a.value) - this.getValueRank(b.value))
                            .slice(0, requiredSingles);
                        airplaneWithSingles.push([...airplane, ...singles]);
                    }
                });
                
                return airplaneWithSingles.sort((a, b) => this.getValueRank(b[0].value) - this.getValueRank(a[0].value));
            }
            
            // è¾…åŠ©å‡½æ•°ï¼šæŸ¥æ‰¾å¯å‡ºçš„å•ç‰Œ
            findPlayableSingle(cards, currentValue, playerType) {
                const playable = cards.filter(c => this.getValueRank(c.value) > currentValue);
                
                if (playable.length === 0) return [];
                
                // åœ°ä¸»å°½é‡å‡ºæœ€å¤§çš„ï¼Œå†œæ°‘å°½é‡å‡ºæœ€å°çš„èƒ½å‹çš„
                if (playerType === 'landlord') {
                    return [playable[0]];
                } else {
                    return [playable[playable.length - 1]];
                }
            }
            
            // è¾…åŠ©å‡½æ•°ï¼šæŸ¥æ‰¾å¯å‡ºçš„å¯¹å­
            findPlayablePair(cards, currentValue, playerType) {
                const pairs = this.findPairs(cards);
                const playable = pairs.filter(p => this.getValueRank(p[0].value) > currentValue);
                
                if (playable.length === 0) return [];
                
                // åœ°ä¸»å°½é‡å‡ºæœ€å¤§çš„ï¼Œå†œæ°‘å°½é‡å‡ºæœ€å°çš„èƒ½å‹çš„
                if (playerType === 'landlord') {
                    return playable[0];
                } else {
                    return playable[playable.length - 1];
                }
            }
            
            // è¾…åŠ©å‡½æ•°ï¼šæŸ¥æ‰¾å¯å‡ºçš„ä¸‰å¼ 
            findPlayableTriple(cards, currentValue) {
                const triples = this.findTriples(cards);
                const playable = triples.filter(t => this.getValueRank(t[0].value) > currentValue);
                
                return playable.length > 0 ? playable[0] : [];
            }
            
            // è¾…åŠ©å‡½æ•°ï¼šæŸ¥æ‰¾å¯å‡ºçš„é¡ºå­
            findPlayableStraight(cards, currentValue, requiredLength) {
                const straights = this.findStraights(cards).filter(s => s.length === requiredLength);
                const playable = straights.filter(s => this.getValueRank(s[0].value) > currentValue);
                
                return playable.length > 0 ? playable[0] : [];
            }
            
            // è¾…åŠ©å‡½æ•°ï¼šæŸ¥æ‰¾å¯å‡ºçš„è¿å¯¹
            findPlayableStraightPair(cards, currentValue, requiredLength) {
                const straightPairs = this.findStraightPairs(cards).filter(s => s.length === requiredLength);
                const playable = straightPairs.filter(s => this.getValueRank(s[0].value) > currentValue);
                
                return playable.length > 0 ? playable[0] : [];
            }
            
            // è¾…åŠ©å‡½æ•°ï¼šæŸ¥æ‰¾å¯å‡ºçš„ç‚¸å¼¹
            findPlayableBomb(cards, currentValue) {
                const bombs = this.findBombs(cards);
                const playable = bombs.filter(b => this.getValueRank(b[0].value) > currentValue);
                
                // æ£€æŸ¥æ˜¯å¦æœ‰ç‹ç‚¸
                const hasBigJoker = cards.some(c => c.value === 'big');
                const hasSmallJoker = cards.some(c => c.value === 'small');
                
                if (hasBigJoker && hasSmallJoker) {
                    return cards.filter(c => c.value === 'big' || c.value === 'small');
                }
                
                return playable.length > 0 ? playable[0] : [];
            }
            
            // è·å–ç‰Œå€¼å¤§å°
            getValueRank(value) {
                const ranks = {
                    '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10,
                    'J': 11, 'Q': 12, 'K': 13, 'A': 14, '2': 15,
                    'small': 16, 'big': 17
                };
                return ranks[value];
            }
            
            // éªŒè¯ç‰Œå‹
            validateCards(cards) {
                if (cards.length === 0) return false;
                
                // é¦–å…ˆéªŒè¯ç‰Œå‹æ˜¯å¦åˆæ³•
                const cardType = this.getCardType(cards);
                if (!cardType) {
                    console.log('âŒ æ— æ•ˆçš„ç‰Œå‹ç»„åˆ');
                    return false;
                }
                
                console.log(`ğŸ¯ æ£€æµ‹åˆ°ç‰Œå‹: ${cardType.name}, å¤§å°: ${cardType.rank}`);
                
                // å¦‚æœæ˜¯è‡ªç”±ç‰Œé˜¶æ®µï¼Œåªè¦ç‰Œå‹åˆæ³•å°±å¯ä»¥å‡º
                if (this.currentCards === null) {
                    return true;
                }
                
                // è·å–å½“å‰å‡ºç‰Œçš„ç‰Œå‹
                const currentCardType = this.getCardType(this.currentCards);
                if (!currentCardType) {
                    console.log('âŒ å½“å‰å‡ºç‰Œç‰Œå‹æ— æ•ˆ');
                    return false;
                }
                
                // ç‚¸å¼¹å¯ä»¥æ‰“ä»»ä½•ç‰Œå‹
                if (cardType.type === 'bomb' || cardType.type === 'rocket') {
                    // ç‹ç‚¸å¯ä»¥æ‰“ä»»ä½•ç‰Œ
                    if (cardType.type === 'rocket') {
                        return true;
                    }
                    // ç‚¸å¼¹å¯ä»¥æ‰“éç‚¸å¼¹ç‰Œå‹ï¼Œæˆ–è€…æ›´å¤§çš„ç‚¸å¼¹
                    return currentCardType.type !== 'rocket' && 
                           (currentCardType.type !== 'bomb' || 
                            cardType.rank > currentCardType.rank);
                }
                
                // éç‚¸å¼¹ç‰Œå‹å¿…é¡»å’Œå½“å‰å‡ºç‰Œç‰Œå‹ä¸€è‡´
                if (cardType.type !== currentCardType.type || 
                    cardType.length !== currentCardType.length) {
                    console.log('âŒ ç‰Œå‹ä¸åŒ¹é…');
                    return false;
                }
                
                // æ¯”è¾ƒç‰Œå‹å¤§å°
                return cardType.rank > currentCardType.rank;
            }
            
            // è·å–ç‰Œå‹ä¿¡æ¯ - å¢å¼ºç‰ˆï¼Œæ”¯æŒæ‰€æœ‰æ–—åœ°ä¸»ç‰Œå‹
            getCardType(cards) {
                if (cards.length === 0) return null;
                
                // æŒ‰ç‰Œå€¼æ’åº
                const sortedCards = [...cards].sort((a, b) => this.getValueRank(b.value) - this.getValueRank(a.value));
                
                // ç‹ç‚¸
                if (cards.length === 2 && 
                    ((cards[0].suit === 'joker' && cards[1].suit === 'joker') ||
                     (cards[1].suit === 'joker' && cards[0].suit === 'joker'))) {
                    return { type: 'rocket', name: 'ç‹ç‚¸', rank: Infinity, length: 2 };
                }
                
                // å•ç‰Œ
                if (cards.length === 1) {
                    return { type: 'single', name: 'å•ç‰Œ', rank: this.getValueRank(sortedCards[0].value), length: 1 };
                }
                
                // å¯¹å­
                if (cards.length === 2 && sortedCards[0].value === sortedCards[1].value) {
                    return { type: 'pair', name: 'å¯¹å­', rank: this.getValueRank(sortedCards[0].value), length: 2 };
                }
                
                // ä¸‰å¼ 
                if (cards.length === 3 && 
                    sortedCards[0].value === sortedCards[1].value && 
                    sortedCards[1].value === sortedCards[2].value) {
                    return { type: 'triple', name: 'ä¸‰å¼ ', rank: this.getValueRank(sortedCards[0].value), length: 3 };
                }
                
                // ç‚¸å¼¹ï¼ˆ4å¼ ç›¸åŒï¼‰
                if (cards.length === 4 && 
                    sortedCards[0].value === sortedCards[1].value && 
                    sortedCards[1].value === sortedCards[2].value && 
                    sortedCards[2].value === sortedCards[3].value) {
                    return { type: 'bomb', name: 'ç‚¸å¼¹', rank: this.getValueRank(sortedCards[0].value), length: 4 };
                }
                
                // ä¸‰å¸¦ä¸€ï¼ˆ3+1ï¼‰
                if (cards.length === 4) {
                    const valueCounts = this.getValueCounts(sortedCards);
                    const tripleValue = Object.keys(valueCounts).find(v => valueCounts[v] === 3);
                    const singleValue = Object.keys(valueCounts).find(v => valueCounts[v] === 1);
                    
                    if (tripleValue && singleValue) {
                        return { 
                            type: 'triple_plus_single', 
                            name: 'ä¸‰å¸¦ä¸€', 
                            rank: this.getValueRank(tripleValue), 
                            length: 4,
                            mainValue: tripleValue,
                            attachValue: singleValue
                        };
                    }
                }
                
                // ä¸‰å¸¦äºŒï¼ˆ3+2ï¼‰
                if (cards.length === 5) {
                    const valueCounts = this.getValueCounts(sortedCards);
                    const tripleValue = Object.keys(valueCounts).find(v => valueCounts[v] === 3);
                    const pairValue = Object.keys(valueCounts).find(v => valueCounts[v] === 2);
                    
                    if (tripleValue && pairValue) {
                        return { 
                            type: 'triple_plus_pair', 
                            name: 'ä¸‰å¸¦äºŒ', 
                            rank: this.getValueRank(tripleValue), 
                            length: 5,
                            mainValue: tripleValue,
                            attachValue: pairValue
                        };
                    }
                }
                
                // é¡ºå­ï¼ˆ5å¼ æˆ–æ›´å¤šè¿ç»­å•ç‰Œï¼Œä¸åŒ…æ‹¬2å’Œå¤§å°ç‹ï¼‰
                if (this.isStraight(sortedCards)) {
                    return { type: 'straight', name: 'é¡ºå­', rank: this.getValueRank(sortedCards[0].value), length: cards.length };
                }
                
                // è¿å¯¹ï¼ˆ3å¯¹æˆ–æ›´å¤šè¿ç»­å¯¹å­ï¼Œä¸åŒ…æ‹¬2å’Œå¤§å°ç‹ï¼‰
                if (this.isStraightPair(sortedCards)) {
                    return { type: 'straight_pair', name: 'è¿å¯¹', rank: this.getValueRank(sortedCards[0].value), length: cards.length };
                }
                
                // é£æœºï¼ˆè¿ç»­çš„ä¸‰å¼ ï¼Œ3+3ï¼Œ3+3+3ç­‰ï¼‰
                const planeResult = this.isPlane(sortedCards);
                if (planeResult) {
                    return {
                        type: 'plane',
                        name: 'é£æœº',
                        rank: this.getValueRank(planeResult.highestValue),
                        length: cards.length,
                        planeCount: planeResult.count,
                        highestValue: planeResult.highestValue
                    };
                }
                
                // é£æœºå¸¦ç¿¼ï¼ˆé£æœº+å•ç‰Œæˆ–å¯¹å­ï¼‰
                const planeWithWingResult = this.isPlaneWithWing(sortedCards);
                if (planeWithWingResult) {
                    return {
                        type: 'plane_with_wing',
                        name: 'é£æœºå¸¦ç¿¼',
                        rank: this.getValueRank(planeWithWingResult.highestValue),
                        length: cards.length,
                        planeCount: planeWithWingResult.count,
                        highestValue: planeWithWingResult.highestValue,
                        wingType: planeWithWingResult.wingType
                    };
                }
                
                return null; // æ— æ•ˆç‰Œå‹
            }
            
            // è·å–ç‰Œå€¼å‡ºç°æ¬¡æ•°
            getValueCounts(cards) {
                const counts = {};
                cards.forEach(card => {
                    counts[card.value] = (counts[card.value] || 0) + 1;
                });
                return counts;
            }
            
            // åˆ¤æ–­æ˜¯å¦ä¸ºé£æœºï¼ˆè¿ç»­çš„ä¸‰å¼ ï¼‰
            isPlane(cards) {
                const valueCounts = this.getValueCounts(cards);
                const tripleValues = Object.keys(valueCounts).filter(v => valueCounts[v] === 3);
                
                if (tripleValues.length < 2) return null;
                
                // æ£€æŸ¥æ˜¯å¦è¿ç»­
                const sortedTripleValues = tripleValues.sort((a, b) => this.getValueRank(b) - this.getValueRank(a));
                
                for (let i = 0; i < sortedTripleValues.length - 1; i++) {
                    const currentRank = this.getValueRank(sortedTripleValues[i]);
                    const nextRank = this.getValueRank(sortedTripleValues[i + 1]);
                    
                    // ä¸èƒ½åŒ…å«2æˆ–å¤§å°ç‹
                    if (sortedTripleValues[i] === '2' || sortedTripleValues[i + 1] === '2' || 
                        sortedTripleValues[i] === 'big' || sortedTripleValues[i] === 'small') {
                        return null;
                    }
                    
                    if (currentRank - nextRank !== 1) {
                        return null;
                    }
                }
                
                // æ£€æŸ¥æ€»ç‰Œæ•°æ˜¯å¦æ­£ç¡®
                const expectedLength = tripleValues.length * 3;
                if (cards.length !== expectedLength) return null;
                
                return {
                    count: tripleValues.length,
                    highestValue: sortedTripleValues[0]
                };
            }
            
            // åˆ¤æ–­æ˜¯å¦ä¸ºé£æœºå¸¦ç¿¼
            isPlaneWithWing(cards) {
                const valueCounts = this.getValueCounts(cards);
                const tripleValues = Object.keys(valueCounts).filter(v => valueCounts[v] === 3);
                
                if (tripleValues.length < 2) return null;
                
                // æ£€æŸ¥æ˜¯å¦è¿ç»­
                const sortedTripleValues = tripleValues.sort((a, b) => this.getValueRank(b) - this.getValueRank(a));
                
                for (let i = 0; i < sortedTripleValues.length - 1; i++) {
                    const currentRank = this.getValueRank(sortedTripleValues[i]);
                    const nextRank = this.getValueRank(sortedTripleValues[i + 1]);
                    
                    // ä¸èƒ½åŒ…å«2æˆ–å¤§å°ç‹
                    if (sortedTripleValues[i] === '2' || sortedTripleValues[i + 1] === '2' || 
                        sortedTripleValues[i] === 'big' || sortedTripleValues[i] === 'small') {
                        return null;
                    }
                    
                    if (currentRank - nextRank !== 1) {
                        return null;
                    }
                }
                
                const planeCount = tripleValues.length;
                const planeLength = planeCount * 3;
                const wingLength = cards.length - planeLength;
                
                // æ£€æŸ¥å¸¦ç¿¼æ•°é‡æ˜¯å¦æ­£ç¡®
                if (wingLength !== planeCount && wingLength !== planeCount * 2) {
                    return null;
                }
                
                // æ£€æŸ¥å¸¦ç¿¼ç±»å‹
                const wingValues = Object.keys(valueCounts).filter(v => valueCounts[v] === 1 || valueCounts[v] === 2);
                const wingCounts = wingValues.map(v => valueCounts[v]);
                
                if (wingLength === planeCount && wingCounts.every(count => count === 1)) {
                    return {
                        count: planeCount,
                        highestValue: sortedTripleValues[0],
                        wingType: 'single'
                    };
                }
                
                if (wingLength === planeCount * 2 && wingCounts.every(count => count === 2)) {
                    return {
                        count: planeCount,
                        highestValue: sortedTripleValues[0],
                        wingType: 'pair'
                    };
                }
                
                return null;
            }
            
            // åˆ¤æ–­æ˜¯å¦ä¸ºé¡ºå­
            isStraight(cards) {
                if (cards.length < 5 || cards.length > 12) return false;
                
                // æ£€æŸ¥æ˜¯å¦åŒ…å«2æˆ–å¤§å°ç‹
                for (const card of cards) {
                    if (card.value === '2' || card.suit === 'joker') {
                        return false;
                    }
                }
                
                // æ£€æŸ¥æ˜¯å¦è¿ç»­
                for (let i = 0; i < cards.length - 1; i++) {
                    const currentRank = this.getValueRank(cards[i].value);
                    const nextRank = this.getValueRank(cards[i + 1].value);
                    if (currentRank - nextRank !== 1) {
                        return false;
                    }
                }
                
                return true;
            }
            
            // åˆ¤æ–­æ˜¯å¦ä¸ºè¿å¯¹
            isStraightPair(cards) {
                if (cards.length < 4 || cards.length % 2 !== 0) return false;
                
                const pairCount = cards.length / 2;
                
                // æ£€æŸ¥æ¯å¯¹æ˜¯å¦ç›¸åŒ
                for (let i = 0; i < cards.length; i += 2) {
                    if (cards[i].value !== cards[i + 1].value) {
                        return false;
                    }
                }
                
                // æ£€æŸ¥æ˜¯å¦è¿ç»­
                for (let i = 0; i < pairCount - 1; i++) {
                    const currentRank = this.getValueRank(cards[i * 2].value);
                    const nextRank = this.getValueRank(cards[(i + 1) * 2].value);
                    if (currentRank - nextRank !== 1) {
                        return false;
                    }
                }
                
                return true;
            }
            
            // åˆ‡æ¢å¡ç‰Œé€‰æ‹©
            toggleCardSelection(index) {
                const card = this.playerCards['bottom'][index];
                const cardElement = this.elements.playerCards['bottom'].children[index];
                
                const selectedIndex = this.selectedCards.findIndex(c => 
                    c.suit === card.suit && c.value === card.value
                );
                
                if (selectedIndex > -1) {
                    // å–æ¶ˆé€‰æ‹©
                    this.selectedCards.splice(selectedIndex, 1);
                    cardElement.classList.remove('selected');
                    cardElement.style.transform = '';
                } else {
                    // é€‰æ‹©å¡ç‰Œ
                    this.selectedCards.push(card);
                    cardElement.classList.add('selected');
                    cardElement.style.transform = 'translateY(-10px)';
                }
            }
            
            // æ˜¾ç¤ºå½“å‰å‡ºç‰Œ
            showCurrentCards(player, cards) {
                // æ¸…é™¤ä¹‹å‰çš„å‡ºç‰Œæ˜¾ç¤ºï¼Œç¡®ä¿æ¯æ¬¡åªæœ‰å½“å‰ç©å®¶çš„å‡ºç‰Œæ˜¾ç¤º
                this.clearCurrentCards();
                
                const container = this.elements.playerCurrentCards[player];
                container.innerHTML = '';
                
                if (player === 'left') {
                    // å·¦å®¶å‡ºç‰Œï¼šå‚ç›´å †å æ˜¾ç¤ºï¼Œæ˜¾ç¤ºæ‰€æœ‰ç‰Œ
                    const cardWidth = 40;
                    const cardHeight = 56;
                    const spacing = 8; // å‡å°é—´è·
                    
                    // è®¾ç½®å®¹å™¨æ ·å¼ï¼Œç¡®ä¿ä¸å½±å“å…¶ä»–å…ƒç´ 
                    container.style.cssText = `
                        position: relative;
                        width: ${cardWidth}px;
                        height: auto;
                        max-height: 300px;
                        overflow: visible;
                        z-index: 10;
                    `;
                    
                    cards.forEach((card, index) => {
                        const cardElement = this.createCardElement(card);
                        cardElement.style.cssText = `
                            position: absolute;
                            top: ${index * spacing}px;
                            left: 0;
                            width: ${cardWidth}px;
                            height: ${cardHeight}px;
                            z-index: ${index};
                            transform: rotate(0deg);
                            transition: all 0.2s ease;
                            cursor: pointer;
                        `;
                        
                        // æ·»åŠ æ‚¬åœæ•ˆæœ - æ”¾å¤§å¹¶æ˜¾ç¤ºåœ¨å±å¹•ä¸­é—´
                        cardElement.addEventListener('mouseenter', function() {
                            // åˆ›å»ºæ”¾å¤§æ˜¾ç¤ºåŒºåŸŸ
                            let zoomContainer = document.getElementById('cardZoomContainer');
                            if (!zoomContainer) {
                                zoomContainer = document.createElement('div');
                                zoomContainer.id = 'cardZoomContainer';
                                zoomContainer.style.cssText = `
                                    position: fixed;
                                    top: 50%;
                                    left: 50%;
                                    transform: translate(-50%, -50%);
                                    z-index: 1000;
                                    display: flex;
                                    gap: 10px;
                                    padding: 20px;
                                    background: rgba(0, 0, 0, 0.8);
                                    border-radius: 10px;
                                    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.5);
                                    pointer-events: none;
                                `;
                                document.body.appendChild(zoomContainer);
                            }
                            
                            // æ¸…ç©ºå¹¶é‡æ–°æ˜¾ç¤ºæ‰€æœ‰ç‰Œ
                            zoomContainer.innerHTML = '';
                            zoomContainer.style.display = 'flex';
                            
                            // æ˜¾ç¤ºæ‰€æœ‰å·¦å®¶å‡ºçš„ç‰Œ
                            cards.forEach((card, idx) => {
                                const zoomCard = document.createElement('div');
                                zoomCard.className = 'card';
                                zoomCard.style.cssText = `
                                    width: 60px;
                                    height: 84px;
                                    transform: rotate(0deg);
                                    z-index: ${idx + 1000};
                                    pointer-events: none;
                                `;
                                
                                // è®¾ç½®å¡ç‰Œæ ·å¼
                                if (card.suit === 'joker') {
                                    zoomCard.classList.add('joker');
                                    zoomCard.textContent = card.value === 'big' ? 'ğŸƒ' : 'ğŸƒŸ';
                                    zoomCard.style.backgroundColor = card.value === 'big' ? '#ffd700' : '#ffffff';
                                    zoomCard.style.color = card.value === 'big' ? '#000000' : '#ff0000';
                                } else {
                                    const suitSymbols = {
                                        'spades': 'â™ ',
                                        'hearts': 'â™¥',
                                        'clubs': 'â™£',
                                        'diamonds': 'â™¦'
                                    };
                                    zoomCard.innerHTML = `
                                        <div class="card-value top-left">${card.value}${suitSymbols[card.suit]}</div>
                                        <div class="card-suit center">${suitSymbols[card.suit]}</div>
                                        <div class="card-value bottom-right">${card.value}${suitSymbols[card.suit]}</div>
                                    `;
                                    zoomCard.style.backgroundColor = card.suit === 'hearts' || card.suit === 'diamonds' ? '#fff' : '#fff';
                                    zoomCard.style.color = card.suit === 'hearts' || card.suit === 'diamonds' ? '#ff0000' : '#000000';
                                }
                                
                                zoomContainer.appendChild(zoomCard);
                            });
                            
                            // é«˜äº®å½“å‰æ‚¬åœçš„ç‰Œ
                            this.style.zIndex = '100';
                            this.style.transform = 'translateX(10px) scale(1.1)';
                            this.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
                        });
                        
                        cardElement.addEventListener('mouseleave', function() {
                            // éšè—æ”¾å¤§æ˜¾ç¤ºåŒºåŸŸ
                            const zoomContainer = document.getElementById('cardZoomContainer');
                            if (zoomContainer) {
                                zoomContainer.style.display = 'none';
                            }
                            
                            // æ¢å¤åŸæ ·å¼
                            this.style.zIndex = index;
                            this.style.transform = 'translateX(0) scale(1)';
                            this.style.boxShadow = 'none';
                        });
                        container.appendChild(cardElement);
                    });
                    
                    // æ˜¾ç¤ºç‰Œæ•°
                    const countElement = document.createElement('div');
                    countElement.style.cssText = `
                        position: absolute;
                        top: ${cards.length * spacing + cardHeight + 5}px;
                        left: 0;
                        color: white;
                        font-size: 12px;
                        font-weight: bold;
                        white-space: nowrap;
                        z-index: 20;
                    `;
                    countElement.textContent = `Ã—${cards.length}`;
                    container.appendChild(countElement);
                    
                    // è°ƒæ•´å®¹å™¨é«˜åº¦
                    container.style.height = `${cards.length * spacing + cardHeight + 25}px`;
                } else {
                    // å…¶ä»–ç©å®¶ï¼šæ°´å¹³æ˜¾ç¤º
                    cards.forEach((card, index) => {
                        const cardElement = this.createCardElement(card);
                        if (index > 0) {
                            cardElement.style.marginLeft = '-35px'; // æ°´å¹³å †å 
                        }
                        container.appendChild(cardElement);
                    });
                }
            }
            
            // æ¸…é™¤å½“å‰å‡ºç‰Œæ˜¾ç¤ºï¼ˆä¿®å¤æ‚¬åœé¢„è§ˆæ®‹ç•™é—®é¢˜ï¼‰
            clearCurrentCards() {
                this.players.forEach(player => {
                    this.elements.playerCurrentCards[player].innerHTML = '';
                });
                
                // åŒæ—¶æ¸…ç†æ‚¬åœé¢„è§ˆå®¹å™¨ï¼Œé˜²æ­¢æ®‹ç•™
                const zoomContainer = document.getElementById('cardZoomContainer');
                if (zoomContainer) {
                    zoomContainer.remove();
                    console.log('ğŸ—‘ï¸  æ¸…ç†æ‚¬åœé¢„è§ˆå®¹å™¨');
                }
            }
            
            // ä¸‹ä¸€ä¸ªç©å®¶
            nextPlayer() {
                const currentIndex = this.players.indexOf(this.currentPlayer);
                this.currentPlayer = this.players[(currentIndex + 1) % 3];
                this.updateStatus(`${this.playerNames[this.currentPlayer]}çš„å›åˆ`);
            }
            
            // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
            checkGameEnd() {
                for (const player of this.players) {
                    if (this.playerCards[player].length === 0) {
                        this.gameOver(player);
                        return true;
                    }
                }
                return false;
            }
            
            // æ¸¸æˆç»“æŸ
            // æ¸¸æˆç»“æŸå¤„ç†
            gameOver(winner) {
                console.log('ğŸ† æ¸¸æˆç»“æŸï¼è·èƒœè€…:', winner);
                
                this.gamePhase = 'ended';
                this.gameStats.totalGames++;
                
                // åˆ¤æ–­èƒœè´Ÿ - ä¿®å¤å†œæ°‘é˜µè¥è·èƒœé€»è¾‘
                const isLandlordWin = winner === this.landlord;
                const isFarmerWin = !isLandlordWin;
                const playerWon = winner === 'bottom' || (isFarmerWin && this.landlord !== 'bottom');
                
                let statusMessage = '';
                let isWin = false;
                
                if (isFarmerWin) {
                    // å†œæ°‘é˜µè¥è·èƒœ
                    console.log('ğŸŒ¾ å†œæ°‘é˜µè¥è·èƒœï¼');
                    if (winner === 'bottom') {
                        isWin = true;
                        statusMessage = 'ğŸ‰ æ­å–œä½ è·èƒœï¼å†œæ°‘é˜µè¥èƒœåˆ©ï¼';
                    } else {
                        // é˜Ÿå‹å†œæ°‘è·èƒœï¼Œç©å®¶ä¹Ÿèµ¢äº†
                        isWin = this.landlord !== 'bottom';
                        statusMessage = `ğŸ‰ ${this.playerNames[winner]}è·èƒœï¼å†œæ°‘é˜µè¥èƒœåˆ©ï¼`;
                    }
                } else {
                    // åœ°ä¸»è·èƒœ
                    console.log('ğŸ‘‘ åœ°ä¸»è·èƒœï¼');
                    isWin = winner === 'bottom';
                    statusMessage = `ğŸ’” ${this.playerNames[winner]}åœ°ä¸»è·èƒœï¼`;
                }
                
                // æ›´æ–°ç»Ÿè®¡
                if (isWin) {
                    this.gameStats.wins++;
                }
                this.updateStats();
                
                // æ˜¾ç¤ºç»“æœ
                this.updateStatus(statusMessage);
                
                // æ¸¸æˆç»“æŸæ—¶æ˜ç‰Œæ‰€æœ‰ç©å®¶çš„æ‰‹ç‰Œ
                this.revealAllPlayersCards();
                
                // æ¸…ç©ºæŒ‰é’®å®¹å™¨å¹¶å¯ç”¨
                this.elements.actionButtons.innerHTML = '';
                this.elements.actionButtons.style.pointerEvents = 'auto';
                
                // æ˜¾ç¤ºæ¸¸æˆç»“æŸç•Œé¢
                this.showGameOverScreen(winner, isWin);
            }
            
            // æ˜ç‰Œæ‰€æœ‰ç©å®¶çš„æ‰‹ç‰Œ
            revealAllPlayersCards() {
                console.log('ğŸƒ æ¸¸æˆç»“æŸï¼Œæ˜ç‰Œæ‰€æœ‰ç©å®¶æ‰‹ç‰Œ');
                
                // æ˜ç‰Œå·¦å®¶çš„æ‰‹ç‰Œï¼ˆå¸¦ç‰¹æ®Šæ‚¬åœæ•ˆæœï¼‰
                this.revealLeftPlayerCards();
                
                // æ˜ç‰Œä¸Šå®¶çš„æ‰‹ç‰Œ
                this.revealTopPlayerCards();
                
                // æ˜ç‰Œç©å®¶è‡ªå·±çš„æ‰‹ç‰Œï¼ˆå¦‚æœè¿˜æœ‰å‰©ä½™ï¼‰
                if (this.playerCards.bottom.length > 0) {
                    this.showPlayerCards('bottom');
                }
            }
            
            // æ˜ç‰Œå·¦å®¶çš„æ‰‹ç‰Œï¼ˆå¸¦ç‰¹æ®Šæ‚¬åœæ•ˆæœï¼‰
            revealLeftPlayerCards() {
                const container = this.elements.playerCards.left;
                container.innerHTML = '';
                
                const cards = this.playerCards.left;
                if (!cards || cards.length === 0) return;
                
                console.log(`ğŸ‘ˆ æ˜ç‰Œå·¦å®¶æ‰‹ç‰Œï¼Œæ•°é‡: ${cards.length}`);
                
                // åˆ›å»ºå¡ç‰Œå±•ç¤ºåŒºåŸŸ
                const cardDisplay = document.createElement('div');
                cardDisplay.className = 'relative';
                cardDisplay.style.cursor = 'pointer';
                
                // æ˜¾ç¤ºç¬¬ä¸€å¼ å¡ç‰Œçš„æ­£é¢
                if (cards.length > 0) {
                    const firstCard = cards[0];
                    const cardElement = this.createCardElement(firstCard);
                    cardElement.className += ' animate-flip';
                    cardDisplay.appendChild(cardElement);
                }
                
                // æ˜¾ç¤ºç‰Œæ•°æ–‡æœ¬
                const countElement = document.createElement('div');
                countElement.className = 'text-white text-xl font-bold mt-2';
                countElement.textContent = `Ã—${cards.length}`;
                cardDisplay.appendChild(countElement);
                
                // æ·»åŠ æ‚¬åœäº‹ä»¶ï¼Œæ˜¾ç¤ºæ‰€æœ‰æ‰‹ç‰Œåœ¨å±å¹•ä¸­å¤®
                cardDisplay.addEventListener('mouseenter', () => {
                    this.showAllCardsInCenter('left', cards);
                });
                
                cardDisplay.addEventListener('mouseleave', () => {
                    this.hideAllCardsInCenter();
                });
                
                container.appendChild(cardDisplay);
            }
            
            // æ˜ç‰Œä¸Šå®¶çš„æ‰‹ç‰Œï¼ˆå³æœ€ä¸Šï¼Œå·¦æœ€ä¸‹ï¼‰
            revealTopPlayerCards() {
                const container = this.elements.playerCards.top;
                container.innerHTML = '';
                
                const cards = this.playerCards.top;
                if (!cards || cards.length === 0) return;
                
                console.log(`ğŸ‘† æ˜ç‰Œä¸Šå®¶æ‰‹ç‰Œï¼Œæ•°é‡: ${cards.length}`);
                
                // æŒ‰é¡ºåºæ˜¾ç¤ºæ‰€æœ‰å¡ç‰Œï¼ˆå³æœ€ä¸Šï¼Œå·¦æœ€ä¸‹ï¼‰
                cards.forEach((card, index) => {
                    const cardElement = this.createCardElement(card);
                    cardElement.style.marginRight = '-35px'; // ä»å³å¾€å·¦å †å 
                    cardElement.style.zIndex = index; // å³è¾¹çš„ç‰Œz-indexæ›´é«˜
                    cardElement.className += ' animate-flip';
                    container.appendChild(cardElement);
                });
                
                // æ˜¾ç¤ºç‰Œæ•°æ–‡æœ¬
                const countElement = document.createElement('div');
                countElement.className = 'text-white font-bold absolute -left-10 top-1/2 transform -translate-y-1/2';
                countElement.textContent = `è¿˜æœ‰${cards.length}å¼ `;
                container.appendChild(countElement);
            }
            
            // åœ¨å±å¹•ä¸­å¤®æ˜¾ç¤ºæ‰€æœ‰å¡ç‰Œ
            showAllCardsInCenter(player, cards) {
                // ç§»é™¤ç°æœ‰çš„ä¸­å¤®æ˜¾ç¤ºåŒºåŸŸ
                this.hideAllCardsInCenter();
                
                // åˆ›å»ºä¸­å¤®æ˜¾ç¤ºåŒºåŸŸ
                const centerDisplay = document.createElement('div');
                centerDisplay.id = 'centerCardDisplay';
                centerDisplay.className = 'fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50';
                centerDisplay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 50;
                    cursor: pointer;
                `;
                
                // åˆ›å»ºå¡ç‰Œå®¹å™¨
                const cardsContainer = document.createElement('div');
                cardsContainer.className = 'flex flex-wrap justify-center gap-2 max-w-4xl';
                cardsContainer.style.cssText = `
                    display: flex;
                    flex-wrap: wrap;
                    justify-content: center;
                    gap: 8px;
                    max-width: 800px;
                    max-height: 70vh;
                    overflow-y: auto;
                    padding: 20px;
                `;
                
                // æŒ‰ç‰Œå‹åˆ†ç»„æ˜¾ç¤ºå¡ç‰Œ
                const sortedCards = [...cards].sort((a, b) => this.getValueRank(b.value) - this.getValueRank(a.value));
                
                sortedCards.forEach(card => {
                    const cardElement = this.createCardElement(card);
                    cardElement.className += ' animate-bounce-in';
                    cardElement.style.transform = 'scale(1.1)';
                    cardsContainer.appendChild(cardElement);
                });
                
                // æ·»åŠ æ ‡é¢˜
                const title = document.createElement('div');
                title.className = 'text-white text-2xl font-bold mb-4';
                title.textContent = `${this.playerNames[player]}çš„æ‰‹ç‰Œ`;
                
                centerDisplay.appendChild(title);
                centerDisplay.appendChild(cardsContainer);
                
                // ç‚¹å‡»å…³é—­
                centerDisplay.addEventListener('click', () => {
                    this.hideAllCardsInCenter();
                });
                
                document.body.appendChild(centerDisplay);
            }
            
            // éšè—ä¸­å¤®æ˜¾ç¤ºçš„å¡ç‰Œ
            hideAllCardsInCenter() {
                const centerDisplay = document.getElementById('centerCardDisplay');
                if (centerDisplay) {
                    centerDisplay.remove();
                }
            }
            
            // æ˜¾ç¤ºæ¸¸æˆç»“æŸç•Œé¢
            showGameOverScreen(winner, isWin) {
                // æ¸…ç©ºæŒ‰é’®å®¹å™¨
                this.elements.actionButtons.innerHTML = '';
                
                // åˆ›å»ºé‡æ–°å¼€å§‹æŒ‰é’®
                const restartBtn = document.createElement('button');
                restartBtn.className = 'bg-accent hover:bg-orange-600 text-white px-8 py-4 rounded-lg font-bold transition-all duration-300 transform hover:scale-105 shadow-lg text-xl';
                restartBtn.textContent = 'å†æ¥ä¸€å±€';
                restartBtn.onclick = () => {
                    this.startGame();
                };
                
                this.elements.actionButtons.appendChild(restartBtn);
            }
            
            // é«˜äº®ç©å®¶
            highlightPlayer(player) {
                this.elements.players[player].classList.add('player-highlight');
            }
            
            // å–æ¶ˆé«˜äº®ç©å®¶
            unhighlightPlayer(player) {
                this.elements.players[player].classList.remove('player-highlight');
            }
            
            // æ˜¾ç¤ºç©å®¶çŠ¶æ€
            showStatus(player, text) {
                this.elements.playerStatus[player].textContent = text;
            }
            
            // éšè—ç©å®¶çŠ¶æ€
            hideStatus(player) {
                this.elements.playerStatus[player].textContent = '';
            }
            
            // æ›´æ–°æ¸¸æˆçŠ¶æ€
            updateStatus(text) {
                this.elements.gameStatus.textContent = text;
            }
            
            // æ›´æ–°ç©å®¶ä¿¡æ¯
            updatePlayerInfo() {
                this.elements.humanCardsCount.textContent = `${this.playerCards.bottom.length}å¼ `;
                this.elements.leftCardsCount.textContent = `${this.playerCards.left.length}å¼ `;
                this.elements.topCardsCount.textContent = `${this.playerCards.top.length}å¼ `;
                
                // å¼ºåˆ¶æ›´æ–°åœ°ä¸»æ ‡ç­¾ï¼Œç¡®ä¿æ ·å¼ç”Ÿæ•ˆ
                console.log('ğŸ¯ è°ƒç”¨updatePlayerInfoï¼Œå½“å‰åœ°ä¸»:', this.landlord);
                this.updateLandlordTags();
            }
            
            // æ›´æ–°åœ°ä¸»æ ‡ç­¾ - å¼ºåˆ¶æ˜¾ç¤º
            // æ›´æ–°åœ°ä¸»å’Œå†œæ°‘æ ‡ç­¾
            updateLandlordTags() {
                console.log('ğŸ”„ æ›´æ–°åœ°ä¸»å’Œå†œæ°‘æ ‡ç­¾ï¼Œå½“å‰åœ°ä¸»:', this.landlord);
                
                // éšè—æ‰€æœ‰ç©å®¶çš„æ ‡ç­¾å¹¶é‡ç½®æ ·å¼
                Object.keys(this.elements.players).forEach(playerKey => {
                    const playerInfo = this.elements.players[playerKey].querySelector('.player-info');
                    const landlordTag = playerInfo.querySelector('.landlord-tag');
                    const farmerTag = playerInfo.querySelector('.farmer-tag');
                    const nameElement = playerInfo.querySelector(`#${playerKey}PlayerName`);
                    
                    console.log(`ğŸ“ æ£€æŸ¥ç©å®¶ ${playerKey} çš„æ ‡ç­¾å…ƒç´ :`);
                    console.log(`   - åœ°ä¸»æ ‡ç­¾å­˜åœ¨: ${!!landlordTag}`);
                    console.log(`   - å†œæ°‘æ ‡ç­¾å­˜åœ¨: ${!!farmerTag}`);
                    
                    // éšè—æ‰€æœ‰æ ‡ç­¾
                    if (landlordTag) {
                        landlordTag.style.display = 'none';
                        landlordTag.classList.add('hidden');
                    }
                    if (farmerTag) {
                        farmerTag.style.display = 'none';
                        farmerTag.classList.add('hidden');
                    }
                    
                    // é‡ç½®åå­—æ ·å¼
                    if (nameElement) {
                        nameElement.style.color = '#ffffff';
                        nameElement.style.fontWeight = 'normal';
                        nameElement.style.textShadow = 'none';
                    }
                    
                    // é‡ç½®ç©å®¶åŒºåŸŸæ ·å¼
                    const playerArea = this.elements.players[playerKey];
                    playerArea.style.backgroundColor = '';
                    playerArea.style.border = '';
                });
                
                // å¦‚æœæœ‰åœ°ä¸»ï¼Œæ˜¾ç¤ºå¯¹åº”æ ‡ç­¾
                if (this.landlord) {
                    console.log(`ğŸ† è®¾ç½®åœ°ä¸»: ${this.landlord}`);
                    
                    // éå†æ‰€æœ‰ç©å®¶ï¼Œè®¾ç½®æ ‡ç­¾
                    Object.keys(this.elements.players).forEach(playerKey => {
                        const playerInfo = this.elements.players[playerKey].querySelector('.player-info');
                        const landlordTag = playerInfo.querySelector('.landlord-tag');
                        const farmerTag = playerInfo.querySelector('.farmer-tag');
                        const nameElement = playerInfo.querySelector(`#${playerKey}PlayerName`);
                        
                        if (playerKey === this.landlord) {
                            // è¿™æ˜¯åœ°ä¸»
                            console.log(`ğŸ‘‘ ${playerKey} æ˜¯åœ°ä¸»`);
                            
                            if (landlordTag && nameElement) {
                                // æ˜¾ç¤ºåœ°ä¸»æ ‡ç­¾
                                landlordTag.style.display = 'inline-block';
                                landlordTag.classList.remove('hidden');
                                
                                // ä¸ºåœ°ä¸»ç©å®¶åŒºåŸŸæ·»åŠ çº¢è‰²è°ƒæ ·å¼
                                const playerArea = this.elements.players[playerKey];
                                playerArea.style.backgroundColor = 'rgba(220, 38, 38, 0.3)'; // çº¢è‰²èƒŒæ™¯
                                playerArea.style.border = '2px solid rgba(239, 68, 68, 0.5)'; // çº¢è‰²è¾¹æ¡†
                                
                                // è°ƒæ•´åœ°ä¸»åå­—æ ·å¼
                                nameElement.style.color = '#fecaca'; // æ·¡çº¢è‰²æ–‡å­—
                                nameElement.style.fontWeight = 'bold';
                                nameElement.style.textShadow = '0 0 5px rgba(239, 68, 68, 0.5)';
                                
                                // ç¡®ä¿æ ‡ç­¾æ ·å¼æ­£ç¡®
                                Object.assign(landlordTag.style, {
                                    backgroundColor: '#ffd700',
                                    color: '#000000',
                                    fontWeight: 'bold',
                                    padding: '2px 6px',
                                    borderRadius: '10px',
                                    fontSize: '10px',
                                    marginLeft: '4px',
                                    zIndex: '9999',
                                    position: 'relative'
                                });
                                
                                console.log(`ğŸ‘‘ æˆåŠŸä¸º${this.playerNames[this.landlord]}æ˜¾ç¤ºåœ°ä¸»æ ‡ç­¾`);
                            }
                        } else {
                            // è¿™æ˜¯å†œæ°‘
                            console.log(`ğŸŒ¾ ${playerKey} æ˜¯å†œæ°‘`);
                            
                            if (farmerTag && nameElement) {
                                // æ˜¾ç¤ºå†œæ°‘æ ‡ç­¾
                                farmerTag.style.display = 'inline-block';
                                farmerTag.classList.remove('hidden');
                                
                                // ä¸ºå†œæ°‘ç©å®¶åŒºåŸŸæ·»åŠ ç»¿è‰²è°ƒæ ·å¼
                                const playerArea = this.elements.players[playerKey];
                                playerArea.style.backgroundColor = 'rgba(34, 197, 94, 0.1)'; // æ·¡ç»¿è‰²èƒŒæ™¯
                                playerArea.style.border = '2px solid rgba(34, 197, 94, 0.3)'; // ç»¿è‰²è¾¹æ¡†
                                
                                // è°ƒæ•´å†œæ°‘åå­—æ ·å¼
                                nameElement.style.color = '#bbf7d0'; // æ·¡ç»¿è‰²æ–‡å­—
                                nameElement.style.fontWeight = 'bold';
                                nameElement.style.textShadow = '0 0 5px rgba(34, 197, 94, 0.5)';
                                
                                // ç¡®ä¿å†œæ°‘æ ‡ç­¾æ ·å¼æ­£ç¡®
                                Object.assign(farmerTag.style, {
                                    backgroundColor: '#22c55e',
                                    color: '#ffffff',
                                    fontWeight: 'bold',
                                    padding: '2px 6px',
                                    borderRadius: '10px',
                                    fontSize: '10px',
                                    marginLeft: '4px',
                                    zIndex: '9999',
                                    position: 'relative'
                                });
                                
                                console.log(`ğŸŒ¾ æˆåŠŸä¸º${this.playerNames[playerKey]}æ˜¾ç¤ºå†œæ°‘æ ‡ç­¾`);
                            }
                        }
                    });
                }
            }
            
            // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
            updateStats() {
                this.elements.totalGames.textContent = this.gameStats.totalGames;
                this.elements.wins.textContent = this.gameStats.wins;
                const winRate = this.gameStats.totalGames > 0 
                    ? Math.round((this.gameStats.wins / this.gameStats.totalGames) * 100) 
                    : 0;
                this.elements.winRate.textContent = `${winRate}%`;
            }
            
            // æ›´æ–°å¸ƒå±€
            updateLayout() {
                // æ ¹æ®å±å¹•å¤§å°è°ƒæ•´å¡ç‰Œå¤§å°
                const screenWidth = window.innerWidth;
                const screenHeight = window.innerHeight;
                
                if (screenWidth < 768) {
                    this.cardWidth = 40;
                    this.cardHeight = 56;
                } else {
                    this.cardWidth = 50;
                    this.cardHeight = 70;
                }
                
                // é‡æ–°æ˜¾ç¤ºå¡ç‰Œ
                if (this.gamePhase !== 'ready') {
                    this.showPlayerCards('bottom');
                    this.showAICards('left');
                    this.showAICards('top');
                }
            }
            
            // æ›´æ–°é¢„è§ˆ
            updatePreview() {
                // æ›´æ–°ç©å®¶ä¿¡æ¯æ˜¾ç¤º
                this.updatePlayerInfo();
            }
            
            // ç­‰å¾…å‡½æ•°
            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }
        
        // CSSæ ·å¼
        const style = document.createElement('style');
        style.textContent = `
            .card {
                width: 50px;
                height: 70px;
                border-radius: 6px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 20px;
                font-weight: bold;
                margin: 0 2px;
                position: relative;
                transition: all 0.2s ease;
            }
            
            .card-back {
                background: linear-gradient(135deg, #2c3e50, #34495e);
                border: 2px solid #ecf0f1;
                box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            }
            
            .card-back::after {
                content: 'ğŸ‚ ';
                font-size: 30px;
                color: #ecf0f1;
            }
            
            .card.spades, .card.clubs {
                color: #000000;
                background: #ffffff;
                border: 2px solid #000000;
            }
            
            .card.hearts, .card.diamonds {
                color: #ff0000;
                background: #ffffff;
                border: 2px solid #ff0000;
            }
            
            .card.joker {
                background: #ffd700;
                color: #000000;
                border: 2px solid #000000;
            }
            
            .card.joker.small {
                background: #ffffff;
                color: #ff0000;
                border: 2px solid #ff0000;
            }
            
            .card.selected {
                border-color: #ffd700 !important;
                box-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
            }
            
            .bottom-card {
                width: 45px;
                height: 63px;
                border-radius: 6px;
                border: 2px solid #ddd;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            }
            
            .action-buttons {
                display: flex;
                justify-content: center;
                gap: 10px;
                margin: 10px 0;
            }
            
            .action-btn {
                transition: all 0.3s ease;
            }
            
            .action-btn:hover {
                transform: translateY(-2px);
                box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            }
            
            .action-btn:active {
                transform: translateY(0);
            }
            
            .player-area {
                transition: all 0.3s ease;
                min-height: 100px;
            }
            
            .player-highlight {
                border: 3px solid #ffd700;
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
                border-radius: 10px;
            }
            
            .card-value {
                position: absolute;
                top: 2px;
                left: 4px;
                font-size: 12px;
                font-weight: bold;
            }
            
            .card-suit {
                position: absolute;
                bottom: 2px;
                right: 4px;
                font-size: 16px;
            }
        `;
        document.head.appendChild(style);
        
        // åˆå§‹åŒ–æ¸¸æˆ
        document.addEventListener('DOMContentLoaded', () => {
            new DoudizhuGame();
        });
    </script>

</body></html>