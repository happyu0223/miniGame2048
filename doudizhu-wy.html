<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æ–—åœ°ä¸»æ¸¸æˆ</title>
  <!-- Tailwind CSS v3 -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Font Awesome -->
  <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
  
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#0f5132',
            secondary: '#1e88e5',
            accent: '#ffc107',
            danger: '#dc3545',
            success: '#28a745',
            dark: '#343a40',
            light: '#f8f9fa'
          },
          fontFamily: {
            sans: ['Inter', 'system-ui', 'sans-serif'],
          },
          animation: {
            'bounce-slow': 'bounce 2s infinite',
            'pulse-slow': 'pulse 3s infinite',
          }
        }
      }
    }
  </script>
  
  <style type="text/tailwindcss">
    @layer utilities {
      .card-shadow {
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      }
      .card-hover:hover {
        transform: translateY(-10px);
        z-index: 10;
      }
      .card-selected {
        transform: translateY(-15px);
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      }
      .card-back {
        background-image: url('https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/rc/pc/super_tool/36ca1c85043a44f4be7d116403f1ce11~tplv-a9rns2rl98-image.image?rcl=202601041845342540CF2EC872BF68FF6B&rk3s=8e244e95&rrcfp=f06b921b&x-expires=1770115589&x-signature=lH0Y8o6pu1rDsPVhHNtaUpOaUYA%3D');
        background-size: cover;
        background-position: center;
      }
      .table-bg {
        background-image: url('https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/rc/pc/super_tool/d3d731370ecc483691b6046ceb6e9c4b~tplv-a9rns2rl98-image.image?rcl=202601041845342540CF2EC872BF68FF6B&rk3s=8e244e95&rrcfp=f06b921b&x-expires=1770115590&x-signature=%2Futc%2B9CPCAOe7yLL7NxYXAkZGTs%3D');
        background-size: cover;
        background-position: center;
      }
      .player-area {
        min-height: 120px;
      }
      .card {
        width: 70px;
        height: 100px;
        border-radius: 8px;
        transition: all 0.2s ease;
      }
      .card-small {
        width: 40px;
        height: 58px;
        border-radius: 4px;
      }
      .landlord-badge {
        position: absolute;
        top: -10px;
        right: -10px;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        background-color: #ffc107;
        color: #000;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 14px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }
      .fade-in {
        animation: fadeIn 0.5s ease-in-out;
      }
      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }
      .slide-up {
        animation: slideUp 0.5s ease-in-out;
      }
      @keyframes slideUp {
        from { transform: translateY(20px); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
      }
      .shake {
        animation: shake 0.5s ease-in-out;
      }
      @keyframes shake {
        0%, 100% { transform: translateX(0); }
        25% { transform: translateX(-5px); }
        75% { transform: translateX(5px); }
      }
      .pulse {
        animation: pulse 1.5s infinite;
      }
      @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.05); }
        100% { transform: scale(1); }
      }
    }
  </style>
</head>
<body class="bg-gray-900 min-h-screen flex flex-col">
  <!-- é¡¶éƒ¨çŠ¶æ€æ  -->
  <header class="bg-primary text-white p-4 shadow-md">
    <div class="container mx-auto flex justify-between items-center">
      <h1 class="text-2xl font-bold">æ–—åœ°ä¸»</h1>
      <div class="flex items-center space-x-4">
        <div class="flex items-center">
          <span class="mr-2">éš¾åº¦:</span>
          <select id="difficulty" class="bg-white text-dark rounded px-2 py-1">
            <option value="easy">ç®€å•</option>
            <option value="normal" selected>æ™®é€š</option>
            <option value="hard">å›°éš¾</option>
          </select>
        </div>
        <button id="newGame" class="bg-accent text-dark px-4 py-2 rounded hover:bg-opacity-80 transition">
          æ–°æ¸¸æˆ
        </button>
      </div>
    </div>
  </header>

  <!-- æ¸¸æˆåŒºåŸŸ -->
  <main class="flex-grow container mx-auto p-4 relative">
    <!-- æ¸¸æˆèƒŒæ™¯ -->
    <div class="table-bg rounded-lg p-6 shadow-xl relative overflow-hidden">
      
      <!-- æ¸¸æˆçŠ¶æ€æç¤º -->
      <div id="gameStatus" class="absolute top-4 left-1/2 transform -translate-x-1/2 bg-dark bg-opacity-70 text-white px-6 py-3 rounded-full text-xl font-bold z-10 fade-in">
        å‡†å¤‡å¼€å§‹
      </div>
      
      <!-- ä¸Šæ–¹AIç©å®¶ -->
      <div class="player-area mb-8 relative">
        <div class="flex flex-col items-center">
          <div class="flex items-center justify-center mb-2">
            <div id="ai1Score" class="bg-white text-dark px-3 py-1 rounded-full font-bold">
              0
            </div>
            <div id="ai1Name" class="ml-3 text-white font-bold">
              å¯¹æ‰‹1
            </div>
            <div id="ai1Landlord" class="landlord-badge hidden">
              åœ°ä¸»
            </div>
          </div>
          <div id="ai1Cards" class="flex space-x-[-25px]">
            <!-- AI1çš„ç‰Œ -->
          </div>
        </div>
      </div>
      
      <!-- ä¸­é—´åŒºåŸŸ -->
      <div class="flex justify-between items-center mb-8">
        <!-- å·¦ä¾§AIç©å®¶ -->
        <div class="player-area w-1/4 relative">
          <div class="flex flex-col items-center">
            <div class="flex items-center justify-center mb-2">
              <div id="ai2Score" class="bg-white text-dark px-3 py-1 rounded-full font-bold">
                0
              </div>
              <div id="ai2Name" class="ml-3 text-white font-bold">
                å¯¹æ‰‹2
              </div>
              <div id="ai2Landlord" class="landlord-badge hidden">
                åœ°ä¸»
              </div>
            </div>
            <div id="ai2Cards" class="flex flex-col space-y-[-15px]">
              <!-- AI2çš„ç‰Œ -->
            </div>
          </div>
        </div>
        
        <!-- åœ°ä¸»ç‰Œå’Œå‡ºç‰ŒåŒº -->
        <div class="flex flex-col items-center w-2/4">
          <!-- åœ°ä¸»ç‰Œ -->
          <div id="landlordCards" class="flex space-x-2 mb-6">
            <!-- åœ°ä¸»ç‰Œ -->
          </div>
          
          <!-- å‡ºç‰ŒåŒº -->
          <div id="playArea" class="min-h-[120px] flex items-center justify-center">
            <!-- å‡ºç‰ŒåŒº -->
          </div>
          
          <!-- å«åœ°ä¸»æŒ‰é’® -->
          <div id="bidButtons" class="hidden mt-4">
            <button id="bidLandlord" class="bg-accent text-dark px-6 py-2 rounded-lg font-bold mr-4 hover:bg-opacity-80 transition">
              å«åœ°ä¸»
            </button>
            <button id="passBid" class="bg-gray-600 text-white px-6 py-2 rounded-lg font-bold hover:bg-opacity-80 transition">
              ä¸å«
            </button>
          </div>
          
          <!-- å‡ºç‰ŒæŒ‰é’® -->
          <div id="playButtons" class="hidden mt-4">
            <button id="playCards" class="bg-success text-white px-6 py-2 rounded-lg font-bold mr-4 hover:bg-opacity-80 transition">
              å‡ºç‰Œ
            </button>
            <button id="passPlay" class="bg-gray-600 text-white px-6 py-2 rounded-lg font-bold hover:bg-opacity-80 transition">
              ä¸å‡º
            </button>
          </div>
        </div>
        
        <!-- å³ä¾§ç©ºç™½ -->
        <div class="w-1/4"></div>
      </div>
      
      <!-- ç©å®¶åŒºåŸŸ -->
      <div class="player-area relative">
        <div class="flex flex-col items-center">
          <div class="flex items-center justify-center mb-2">
            <div id="playerScore" class="bg-white text-dark px-3 py-1 rounded-full font-bold">
              0
            </div>
            <div id="playerName" class="ml-3 text-white font-bold">
              ä½ 
            </div>
            <div id="playerLandlord" class="landlord-badge hidden">
              åœ°ä¸»
            </div>
          </div>
          <div id="playerCards" class="flex flex-wrap justify-center gap-1">
            <!-- ç©å®¶çš„ç‰Œ -->
          </div>
        </div>
      </div>
    </div>
  </main>
  
  <!-- æ¸¸æˆè§„åˆ™è¯´æ˜ -->
  <div class="bg-dark text-white p-4">
    <div class="container mx-auto">
      <h2 class="text-xl font-bold mb-2">æ¸¸æˆè§„åˆ™</h2>
      <p class="mb-2">1. ä¸‰äººæ–—åœ°ä¸»ï¼Œç©å®¶ä¸ä¸¤ä¸ªAIå¯¹æˆ˜</p>
      <p class="mb-2">2. å«åœ°ä¸»é˜¶æ®µï¼Œç©å®¶å¯ä»¥é€‰æ‹©å«åœ°ä¸»æˆ–ä¸å«</p>
      <p class="mb-2">3. åœ°ä¸»è·å¾—3å¼ é¢å¤–ç‰Œï¼Œå…ˆå‡ºç‰Œ</p>
      <p class="mb-2">4. å‡ºç‰Œé˜¶æ®µï¼Œç©å®¶å¯ä»¥é€‰æ‹©å‡ºç‰Œæˆ–ä¸å‡º</p>
      <p class="mb-2">5. å…ˆå‡ºå®Œæ‰‹ä¸­æ‰€æœ‰ç‰Œçš„ç©å®¶è·èƒœ</p>
    </div>
  </div>

  <script>
    // æ¸¸æˆæ•°æ®
    const gameData = {
      // ç©å®¶æ•°æ®
      players: [
        { id: 0, name: 'ä½ ', cards: [], isLandlord: false, score: 0, isAI: false },
        { id: 1, name: 'å¯¹æ‰‹1', cards: [], isLandlord: false, score: 0, isAI: true },
        { id: 2, name: 'å¯¹æ‰‹2', cards: [], isLandlord: false, score: 0, isAI: true }
      ],
      
      // æ¸¸æˆçŠ¶æ€
      currentPlayer: 0,
      currentPhase: 'deal', // deal: å‘ç‰Œé˜¶æ®µ, bid: å«åœ°ä¸»é˜¶æ®µ, play: å‡ºç‰Œé˜¶æ®µ, end: ç»“æŸé˜¶æ®µ
      lastCards: [],
      landlordCards: [],
      difficulty: 'normal',
      bidTurn: 0,
      bidCount: 0,
      turnCount: 0,
      bombCount: 0,
      spring: true,
      
      // ç‰Œå‹å®šä¹‰
      cardTypes: {
        SINGLE: 'å•ç‰Œ',
        PAIR: 'å¯¹å­',
        TRIPLE: 'ä¸‰å¸¦',
        STRAIGHT: 'é¡ºå­',
        STRAIGHT_PAIR: 'è¿å¯¹',
        PLANE: 'é£æœº',
        BOMB: 'ç‚¸å¼¹',
        ROYAL_BOMB: 'ç‹ç‚¸'
      },
      
      // ç‰Œå€¼æ˜ å°„
      cardValues: {
        '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10,
        'J': 11, 'Q': 12, 'K': 13, 'A': 14, '2': 15, 'S': 16, 'B': 17
      },
      
      // ç‰Œé¢æ˜ å°„
      cardFaces: {
        3: '3', 4: '4', 5: '5', 6: '6', 7: '7', 8: '8', 9: '9', 10: '10',
        11: 'J', 12: 'Q', 13: 'K', 14: 'A', 15: '2', 16: 'S', 17: 'B'
      },
      
      // èŠ±è‰²æ˜ å°„
      cardSuits: {
        0: 'spades',    // é»‘æ¡ƒ
        1: 'hearts',    // çº¢æ¡ƒ
        2: 'clubs',     // æ¢…èŠ±
        3: 'diamonds'   // æ–¹å—
      },
      
      // èŠ±è‰²ç¬¦å·
      suitSymbols: {
        0: 'â™ ', 1: 'â™¥', 2: 'â™£', 3: 'â™¦'
      },
      
      // èŠ±è‰²é¢œè‰²
      suitColors: {
        0: 'black',  // é»‘æ¡ƒ - é»‘è‰²
        1: 'red',    // çº¢æ¡ƒ - çº¢è‰²
        2: 'black',  // æ¢…èŠ± - é»‘è‰²
        3: 'red'     // æ–¹å— - çº¢è‰²
      }
    };
    
    // é€‰ä¸­çš„ç‰Œ
    let selectedCards = [];
    
    // åˆå§‹åŒ–æ¸¸æˆ
    function initGame() {
      // é‡ç½®æ¸¸æˆæ•°æ®
      gameData.players.forEach(player => {
        player.cards = [];
        player.isLandlord = false;
      });
      gameData.currentPlayer = 0;
      gameData.currentPhase = 'deal';
      gameData.lastCards = [];
      gameData.landlordCards = [];
      gameData.bidTurn = 0;
      gameData.bidCount = 0;
      gameData.turnCount = 0;
      gameData.bombCount = 0;
      gameData.spring = true;
      selectedCards = [];
      
      // æ›´æ–°UI
      updateGameStatus('å‡†å¤‡å¼€å§‹');
      clearPlayArea();
      clearPlayerCards();
      hideBidButtons();
      hidePlayButtons();
      hideLandlordBadges();
      
      // å¼€å§‹æ¸¸æˆ
      setTimeout(() => {
        dealCards();
      }, 1000);
    }
    
    // æ´—ç‰Œ
    function shuffleCards() {
      const cards = [];
      
      // ç”Ÿæˆ52å¼ ç‰Œ
      for (let suit = 0; suit < 4; suit++) {
        for (let value = 3; value <= 15; value++) {
          cards.push({
            value: value,
            suit: suit,
            face: gameData.cardFaces[value],
            suitSymbol: gameData.suitSymbols[suit],
            color: gameData.suitColors[suit]
          });
        }
      }
      
      // æ·»åŠ å¤§å°ç‹
      cards.push({
        value: 16,
        suit: -1,
        face: 'S',
        suitSymbol: 'ğŸƒ',
        color: 'black'
      });
      cards.push({
        value: 17,
        suit: -1,
        face: 'B',
        suitSymbol: 'ğŸƒ',
        color: 'red'
      });
      
      // æ´—ç‰Œ
      for (let i = cards.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [cards[i], cards[j]] = [cards[j], cards[i]];
      }
      
      return cards;
    }
    
    // å‘ç‰Œ
    function dealCards() {
      updateGameStatus('æ­£åœ¨å‘ç‰Œ...');
      
      // æ´—ç‰Œ
      const cards = shuffleCards();
      
      // å‘ç‰Œ
      for (let i = 0; i < 17; i++) {
        gameData.players[0].cards.push(cards[i]);
        gameData.players[1].cards.push(cards[i + 17]);
        gameData.players[2].cards.push(cards[i + 34]);
      }
      
      // åœ°ä¸»ç‰Œ
      gameData.landlordCards = [cards[51], cards[52], cards[53]];
      
      // æ’åºç©å®¶çš„ç‰Œ
      gameData.players.forEach(player => {
        sortCards(player.cards);
      });
      
      // æ˜¾ç¤ºç©å®¶çš„ç‰Œ
      renderPlayerCards();
      
      // æ˜¾ç¤ºåœ°ä¸»ç‰Œ
      renderLandlordCards();
      
      // å¼€å§‹å«åœ°ä¸»é˜¶æ®µ
      setTimeout(() => {
        startBidPhase();
      }, 2000);
    }
    
    // æ’åºç‰Œ
    function sortCards(cards) {
      cards.sort((a, b) => {
        // å…ˆæŒ‰ç‰Œå€¼æ’åº
        if (a.value !== b.value) {
          return a.value - b.value;
        }
        // å†æŒ‰èŠ±è‰²æ’åº
        return a.suit - b.suit;
      });
    }
    
    // æ¸²æŸ“ç©å®¶çš„ç‰Œ
    function renderPlayerCards() {
      // æ¸²æŸ“ç©å®¶çš„ç‰Œ
      const playerCardsEl = document.getElementById('playerCards');
      playerCardsEl.innerHTML = '';
      
      gameData.players[0].cards.forEach((card, index) => {
        const cardEl = document.createElement('div');
        cardEl.className = 'card card-shadow card-hover cursor-pointer';
        cardEl.dataset.index = index;
        
        // è®¾ç½®ç‰Œçš„æ ·å¼
        cardEl.style.backgroundColor = 'white';
        cardEl.style.border = '1px solid #ccc';
        cardEl.style.display = 'flex';
        cardEl.style.flexDirection = 'column';
        cardEl.style.justifyContent = 'space-between';
        cardEl.style.padding = '5px';
        cardEl.style.position = 'relative';
        
        // è®¾ç½®ç‰Œé¢å†…å®¹
        const textColor = card.color === 'red' ? 'text-red-600' : 'text-gray-900';
        cardEl.innerHTML = `
          <div class="${textColor} font-bold text-lg">
            ${card.face}${card.suit !== -1 ? card.suitSymbol : ''}
          </div>
          <div class="${textColor} font-bold text-2xl flex justify-center">
            ${card.suit !== -1 ? card.suitSymbol : card.face}
          </div>
          <div class="${textColor} font-bold text-lg flex justify-end">
            ${card.face}${card.suit !== -1 ? card.suitSymbol : ''}
          </div>
        `;
        
        // æ·»åŠ ç‚¹å‡»äº‹ä»¶
        cardEl.addEventListener('click', () => {
          if (gameData.currentPhase === 'play' && gameData.currentPlayer === 0) {
            toggleCardSelection(index);
          }
        });
        
        playerCardsEl.appendChild(cardEl);
      });
      
      // æ¸²æŸ“AI1çš„ç‰Œï¼ˆèƒŒé¢ï¼‰
      const ai1CardsEl = document.getElementById('ai1Cards');
      ai1CardsEl.innerHTML = '';
      
      for (let i = 0; i < gameData.players[1].cards.length; i++) {
        const cardEl = document.createElement('div');
        cardEl.className = 'card card-small card-back card-shadow';
        ai1CardsEl.appendChild(cardEl);
      }
      
      // æ¸²æŸ“AI2çš„ç‰Œï¼ˆèƒŒé¢ï¼‰
      const ai2CardsEl = document.getElementById('ai2Cards');
      ai2CardsEl.innerHTML = '';
      
      for (let i = 0; i < gameData.players[2].cards.length; i++) {
        const cardEl = document.createElement('div');
        cardEl.className = 'card-small card-back card-shadow';
        ai2CardsEl.appendChild(cardEl);
      }
    }
    
    // æ¸²æŸ“åœ°ä¸»ç‰Œ
    function renderLandlordCards() {
      const landlordCardsEl = document.getElementById('landlordCards');
      landlordCardsEl.innerHTML = '';
      
      gameData.landlordCards.forEach(card => {
        const cardEl = document.createElement('div');
        cardEl.className = 'card card-shadow';
        
        // è®¾ç½®ç‰Œçš„æ ·å¼
        cardEl.style.backgroundColor = 'white';
        cardEl.style.border = '1px solid #ccc';
        cardEl.style.display = 'flex';
        cardEl.style.flexDirection = 'column';
        cardEl.style.justifyContent = 'space-between';
        cardEl.style.padding = '5px';
        
        // è®¾ç½®ç‰Œé¢å†…å®¹
        const textColor = card.color === 'red' ? 'text-red-600' : 'text-gray-900';
        cardEl.innerHTML = `
          <div class="${textColor} font-bold text-lg">
            ${card.face}${card.suit !== -1 ? card.suitSymbol : ''}
          </div>
          <div class="${textColor} font-bold text-2xl flex justify-center">
            ${card.suit !== -1 ? card.suitSymbol : card.face}
          </div>
          <div class="${textColor} font-bold text-lg flex justify-end">
            ${card.face}${card.suit !== -1 ? card.suitSymbol : ''}
          </div>
        `;
        
        landlordCardsEl.appendChild(cardEl);
      });
    }
    
    // å¼€å§‹å«åœ°ä¸»é˜¶æ®µ
    function startBidPhase() {
      gameData.currentPhase = 'bid';
      gameData.bidTurn = 0;
      gameData.bidCount = 0;
      
      updateGameStatus('å¼€å§‹å«åœ°ä¸»');
      
      // æ˜¾ç¤ºå«åœ°ä¸»æŒ‰é’®
      showBidButtons();
      
      // å¦‚æœæ˜¯ç©å®¶å…ˆå«åœ°ä¸»
      if (gameData.bidTurn === 0) {
        updateGameStatus('è½®åˆ°ä½ å«åœ°ä¸»');
      } else {
        // AIå«åœ°ä¸»
        setTimeout(() => {
          aiBid();
        }, 1000);
      }
    }
    
    // ç©å®¶å«åœ°ä¸»
    function playerBid(isBid) {
      if (isBid) {
        gameData.bidCount++;
        gameData.players[0].isLandlord = true;
        updateGameStatus('ä½ æˆä¸ºäº†åœ°ä¸»');
        setLandlord(0);
      } else {
        updateGameStatus('ä½ é€‰æ‹©äº†ä¸å«');
      }
      
      // éšè—å«åœ°ä¸»æŒ‰é’®
      hideBidButtons();
      
      // å¦‚æœå·²ç»æœ‰ç©å®¶å«åœ°ä¸»ï¼Œå¼€å§‹å‡ºç‰Œé˜¶æ®µ
      if (isBid) {
        setTimeout(() => {
          startPlayPhase();
        }, 1000);
      } else {
        // ä¸‹ä¸€ä¸ªç©å®¶å«åœ°ä¸»
        gameData.bidTurn = (gameData.bidTurn + 1) % 3;
        
        // å¦‚æœä¸‰ä¸ªç©å®¶éƒ½ä¸å«åœ°ä¸»ï¼Œé‡æ–°å¼€å§‹
        if (gameData.bidTurn === 0 && gameData.bidCount === 0) {
          setTimeout(() => {
            initGame();
          }, 1000);
        } else {
          // AIå«åœ°ä¸»
          setTimeout(() => {
            aiBid();
          }, 1000);
        }
      }
    }
    
    // AIå«åœ°ä¸»
    function aiBid() {
      const aiPlayer = gameData.players[gameData.bidTurn];
      updateGameStatus(`è½®åˆ°${aiPlayer.name}å«åœ°ä¸»`);
      
      // æ ¹æ®éš¾åº¦å’Œæ‰‹ç‰Œå†³å®šæ˜¯å¦å«åœ°ä¸»
      let isBid = false;
      
      if (gameData.difficulty === 'easy') {
        // ç®€å•éš¾åº¦ï¼šåªæœ‰å½“æ‰‹ç‰Œä¸­æœ‰è‡³å°‘3ä¸ªç‚¸å¼¹æˆ–å¤§éƒ¨åˆ†æ˜¯å¤§ç‰Œæ—¶æ‰å«åœ°ä¸»
        const bombCount = countBombs(aiPlayer.cards);
        const highCardCount = countHighCards(aiPlayer.cards);
        isBid = bombCount >= 3 || highCardCount >= 10;
      } else if (gameData.difficulty === 'normal') {
        // æ™®é€šéš¾åº¦ï¼šç»¼åˆè€ƒè™‘ç‰Œå‹å®Œæ•´æ€§å’Œå¤§ç‰Œæ•°é‡
        const bombCount = countBombs(aiPlayer.cards);
        const highCardCount = countHighCards(aiPlayer.cards);
        const straightCount = countStraights(aiPlayer.cards);
        isBid = bombCount >= 2 || (highCardCount >= 8 && straightCount >= 2);
      } else {
        // å›°éš¾éš¾åº¦ï¼šç²¾ç¡®è®¡ç®—ç‰Œå‹æ¦‚ç‡å’Œè·èƒœå¯èƒ½æ€§
        const bombCount = countBombs(aiPlayer.cards);
        const highCardCount = countHighCards(aiPlayer.cards);
        const straightCount = countStraights(aiPlayer.cards);
        const pairCount = countPairs(aiPlayer.cards);
        isBid = bombCount >= 1 || (highCardCount >= 6 && (straightCount >= 2 || pairCount >= 3));
      }
      
      // å¦‚æœå·²ç»æœ‰ç©å®¶å«åœ°ä¸»ï¼Œæé«˜å«åœ°ä¸»çš„æ¦‚ç‡
      if (gameData.bidCount > 0) {
        isBid = isBid || Math.random() < 0.5;
      }
      
      setTimeout(() => {
        if (isBid) {
          gameData.bidCount++;
          aiPlayer.isLandlord = true;
          updateGameStatus(`${aiPlayer.name}æˆä¸ºäº†åœ°ä¸»`);
          setLandlord(gameData.bidTurn);
          
          // éšè—å«åœ°ä¸»æŒ‰é’®
          hideBidButtons();
          
          // å¼€å§‹å‡ºç‰Œé˜¶æ®µ
          setTimeout(() => {
            startPlayPhase();
          }, 1000);
        } else {
          updateGameStatus(`${aiPlayer.name}é€‰æ‹©äº†ä¸å«`);
          
          // ä¸‹ä¸€ä¸ªç©å®¶å«åœ°ä¸»
          gameData.bidTurn = (gameData.bidTurn + 1) % 3;
          
          // å¦‚æœä¸‰ä¸ªç©å®¶éƒ½ä¸å«åœ°ä¸»ï¼Œé‡æ–°å¼€å§‹
          if (gameData.bidTurn === 0 && gameData.bidCount === 0) {
            setTimeout(() => {
              initGame();
            }, 1000);
          } else if (gameData.bidTurn === 0) {
            // è½®åˆ°ç©å®¶å«åœ°ä¸»
            setTimeout(() => {
              updateGameStatus('è½®åˆ°ä½ å«åœ°ä¸»');
              showBidButtons();
            }, 1000);
          } else {
            // ä¸‹ä¸€ä¸ªAIå«åœ°ä¸»
            setTimeout(() => {
              aiBid();
            }, 1000);
          }
        }
      }, 1500);
    }
    
    // è®¾ç½®åœ°ä¸»
    function setLandlord(playerIndex) {
      // è®¾ç½®åœ°ä¸»æ ‡å¿—
      gameData.players[playerIndex].isLandlord = true;
      
      // å°†åœ°ä¸»ç‰Œæ·»åŠ ç»™åœ°ä¸»
      gameData.players[playerIndex].cards.push(...gameData.landlordCards);
      
      // æ’åºåœ°ä¸»çš„ç‰Œ
      sortCards(gameData.players[playerIndex].cards);
      
      // æ›´æ–°UI
      renderPlayerCards();
      showLandlordBadge(playerIndex);
      clearLandlordCards();
    }
    
    // æ˜¾ç¤ºåœ°ä¸»æ ‡å¿—
    function showLandlordBadge(playerIndex) {
      hideLandlordBadges();
      
      const landlordBadges = ['playerLandlord', 'ai1Landlord', 'ai2Landlord'];
      document.getElementById(landlordBadges[playerIndex]).classList.remove('hidden');
    }
    
    // éšè—æ‰€æœ‰åœ°ä¸»æ ‡å¿—
    function hideLandlordBadges() {
      document.getElementById('playerLandlord').classList.add('hidden');
      document.getElementById('ai1Landlord').classList.add('hidden');
      document.getElementById('ai2Landlord').classList.add('hidden');
    }
    
    // æ¸…é™¤åœ°ä¸»ç‰Œ
    function clearLandlordCards() {
      const landlordCardsEl = document.getElementById('landlordCards');
      landlordCardsEl.innerHTML = '';
    }
    
    // å¼€å§‹å‡ºç‰Œé˜¶æ®µ
    function startPlayPhase() {
      gameData.currentPhase = 'play';
      
      // æ‰¾åˆ°åœ°ä¸»
      let landlordIndex = 0;
      gameData.players.forEach((player, index) => {
        if (player.isLandlord) {
          landlordIndex = index;
        }
      });
      
      // åœ°ä¸»å…ˆå‡ºç‰Œ
      gameData.currentPlayer = landlordIndex;
      
      updateGameStatus(`å¼€å§‹å‡ºç‰Œï¼Œ${gameData.players[gameData.currentPlayer].name}å…ˆå‡ºç‰Œ`);
      
      // å¼€å§‹å‡ºç‰Œ
      setTimeout(() => {
        startTurn();
      }, 1000);
    }
    
    // å¼€å§‹å›åˆ
    function startTurn() {
      const currentPlayer = gameData.players[gameData.currentPlayer];
      
      updateGameStatus(`è½®åˆ°${currentPlayer.name}å‡ºç‰Œ`);
      
      // å¦‚æœæ˜¯ç©å®¶å›åˆ
      if (gameData.currentPlayer === 0) {
        // æ˜¾ç¤ºå‡ºç‰ŒæŒ‰é’®
        showPlayButtons();
        
        // å¦‚æœä¸Šä¸€è½®æœ‰äººå‡ºç‰Œï¼Œå¯ç”¨ä¸å‡ºæŒ‰é’®
        document.getElementById('passPlay').disabled = gameData.lastCards.length === 0;
      } else {
        // AIå›åˆ
        setTimeout(() => {
          aiPlay();
        }, 1500);
      }
    }
    
    // ç©å®¶å‡ºç‰Œ
    function playerPlay(isPlay) {
      const currentPlayer = gameData.players[gameData.currentPlayer];
      
      if (isPlay) {
        // æ£€æŸ¥é€‰ä¸­çš„ç‰Œæ˜¯å¦åˆæ³•
        if (selectedCards.length === 0) {
          updateGameStatus('è¯·é€‰æ‹©è¦å‡ºçš„ç‰Œ');
          return;
        }
        
        // è·å–é€‰ä¸­çš„ç‰Œ
        const cardsToPlay = [];
        selectedCards.sort((a, b) => b - a); // ä»å¤§åˆ°å°æ’åºï¼Œä»¥ä¾¿ä»æ•°ç»„ä¸­åˆ é™¤
        selectedCards.forEach(index => {
          cardsToPlay.push(currentPlayer.cards[index]);
        });
        
        // æ£€æŸ¥ç‰Œå‹æ˜¯å¦åˆæ³•
        const cardType = checkCardType(cardsToPlay);
        if (cardType === null) {
          updateGameStatus('ç‰Œå‹ä¸åˆæ³•');
          return;
        }
        
        // æ£€æŸ¥æ˜¯å¦èƒ½å‡ºç‰Œ
        if (gameData.lastCards.length > 0) {
          const lastCardType = checkCardType(gameData.lastCards);
          if (!canPlayCards(cardsToPlay, cardType, gameData.lastCards, lastCardType)) {
            updateGameStatus('ä¸èƒ½å‡ºè¿™æ ·çš„ç‰Œ');
            return;
          }
        }
        
        // å‡ºç‰Œ
        playCards(cardsToPlay);
        
        // æ¸…é™¤é€‰ä¸­çš„ç‰Œ
        selectedCards = [];
      } else {
        // ä¸å‡º
        updateGameStatus(`${currentPlayer.name}é€‰æ‹©ä¸å‡º`);
        
        // å¦‚æœä¸Šä¸€è½®æ²¡äººå‡ºç‰Œï¼Œä¸èƒ½ä¸å‡º
        if (gameData.lastCards.length === 0) {
          updateGameStatus('ä¸Šä¸€è½®æ²¡äººå‡ºç‰Œï¼Œå¿…é¡»å‡ºç‰Œ');
          return;
        }
      }
      
      // éšè—å‡ºç‰ŒæŒ‰é’®
      hidePlayButtons();
      
      // æ£€æŸ¥æ˜¯å¦è·èƒœ
      if (currentPlayer.cards.length === 0) {
        setTimeout(() => {
          endGame();
        }, 1000);
        return;
      }
      
      // ä¸‹ä¸€ä¸ªç©å®¶
      gameData.currentPlayer = (gameData.currentPlayer + 1) % 3;
      
      // å¦‚æœè¿ç»­ä¸‰ä¸ªç©å®¶ä¸å‡ºï¼Œé‡ç½®ä¸Šä¸€è½®å‡ºç‰Œ
      if (isPlay === false && gameData.turnCount > 0) {
        gameData.turnCount++;
        if (gameData.turnCount >= 3) {
          gameData.lastCards = [];
          gameData.turnCount = 0;
          updateGameStatus('è¿ç»­ä¸‰ä¸ªç©å®¶ä¸å‡ºï¼Œé‡ç½®å‡ºç‰Œ');
        }
      } else {
        gameData.turnCount = 1;
      }
      
      // å¼€å§‹ä¸‹ä¸€ä¸ªå›åˆ
      setTimeout(() => {
        startTurn();
      }, 1000);
    }
    
    // AIå‡ºç‰Œ
    function aiPlay() {
      const currentPlayer = gameData.players[gameData.currentPlayer];
      
      // æ ¹æ®éš¾åº¦é€‰æ‹©å‡ºç‰Œç­–ç•¥
      let cardsToPlay = [];
      
      if (gameData.difficulty === 'easy') {
        // ç®€å•éš¾åº¦ï¼šåŸºæœ¬ç‰Œå‹è¯†åˆ«ï¼Œå€¾å‘äºå‡ºå¤§ç‰Œ
        cardsToPlay = aiPlayEasy(currentPlayer);
      } else if (gameData.difficulty === 'normal') {
        // æ™®é€šéš¾åº¦ï¼šè€ƒè™‘ç‰Œå‹è¿è´¯æ€§ï¼Œæœ‰ä¸€å®šçš„ç­–ç•¥æ€§
        cardsToPlay = aiPlayNormal(currentPlayer);
      } else {
        // å›°éš¾éš¾åº¦ï¼šæ¨¡æ‹Ÿäººç±»ç©å®¶çš„å‡ºç‰Œä¹ æƒ¯ï¼Œè€ƒè™‘ç‰Œå‹ç»„åˆå’Œå¯¹æ‰‹å¯èƒ½çš„ç‰Œ
        cardsToPlay = aiPlayHard(currentPlayer);
      }
      
      setTimeout(() => {
        if (cardsToPlay.length > 0) {
          // å‡ºç‰Œ
          playCards(cardsToPlay);
        } else {
          // ä¸å‡º
          updateGameStatus(`${currentPlayer.name}é€‰æ‹©ä¸å‡º`);
          
          // å¦‚æœä¸Šä¸€è½®æ²¡äººå‡ºç‰Œï¼Œéšæœºå‡ºä¸€å¼ ç‰Œ
          if (gameData.lastCards.length === 0) {
            const randomIndex = Math.floor(Math.random() * currentPlayer.cards.length);
            const randomCard = [currentPlayer.cards[randomIndex]];
            playCards(randomCard);
            return;
          }
        }
        
        // æ£€æŸ¥æ˜¯å¦è·èƒœ
        if (currentPlayer.cards.length === 0) {
          setTimeout(() => {
            endGame();
          }, 1000);
          return;
        }
        
        // ä¸‹ä¸€ä¸ªç©å®¶
        gameData.currentPlayer = (gameData.currentPlayer + 1) % 3;
        
        // å¦‚æœè¿ç»­ä¸‰ä¸ªç©å®¶ä¸å‡ºï¼Œé‡ç½®ä¸Šä¸€è½®å‡ºç‰Œ
        if (cardsToPlay.length === 0 && gameData.turnCount > 0) {
          gameData.turnCount++;
          if (gameData.turnCount >= 3) {
            gameData.lastCards = [];
            gameData.turnCount = 0;
            updateGameStatus('è¿ç»­ä¸‰ä¸ªç©å®¶ä¸å‡ºï¼Œé‡ç½®å‡ºç‰Œ');
          }
        } else {
          gameData.turnCount = 1;
        }
        
        // å¼€å§‹ä¸‹ä¸€ä¸ªå›åˆ
        setTimeout(() => {
          startTurn();
        }, 1000);
      }, 1500);
    }
    
    // ç®€å•AIå‡ºç‰Œç­–ç•¥
    function aiPlayEasy(player) {
      // å¦‚æœä¸Šä¸€è½®æ²¡äººå‡ºç‰Œï¼Œå‡ºæœ€å°çš„ç‰Œ
      if (gameData.lastCards.length === 0) {
        // æ‰¾åˆ°æœ€å°çš„å•ç‰Œ
        const minCard = [...player.cards].sort((a, b) => a.value - b.value)[0];
        return [minCard];
      }
      
      // å¦åˆ™ï¼Œå°è¯•å‡ºæ¯”ä¸Šä¸€è½®å¤§çš„ç‰Œ
      const lastCardType = checkCardType(gameData.lastCards);
      
      // å°è¯•å‡ºåŒç±»å‹çš„ç‰Œ
      const possibleCards = findPossibleCards(player.cards, lastCardType, gameData.lastCards);
      
      if (possibleCards.length > 0) {
        // é€‰æ‹©æœ€å°çš„å¯å‡ºç‰Œ
        return possibleCards[0];
      }
      
      // å¦‚æœæœ‰ç‚¸å¼¹ï¼Œå‡ºç‚¸å¼¹
      const bombs = findBombs(player.cards);
      if (bombs.length > 0) {
        return bombs[0];
      }
      
      // ä¸å‡º
      return [];
    }
    
    // æ™®é€šAIå‡ºç‰Œç­–ç•¥
    function aiPlayNormal(player) {
      // å¦‚æœä¸Šä¸€è½®æ²¡äººå‡ºç‰Œï¼Œå°è¯•å‡ºç»„åˆç‰Œ
      if (gameData.lastCards.length === 0) {
        // å°è¯•å‡ºé¡ºå­
        const straights = findStraights(player.cards);
        if (straights.length > 0) {
          return straights[straights.length - 1]; // å‡ºæœ€é•¿çš„é¡ºå­
        }
        
        // å°è¯•å‡ºè¿å¯¹
        const straightPairs = findStraightPairs(player.cards);
        if (straightPairs.length > 0) {
          return straightPairs[straightPairs.length - 1]; // å‡ºæœ€é•¿çš„è¿å¯¹
        }
        
        // å°è¯•å‡ºé£æœº
        const planes = findPlanes(player.cards);
        if (planes.length > 0) {
          return planes[0];
        }
        
        // å°è¯•å‡ºä¸‰å¸¦
        const triples = findTriples(player.cards);
        if (triples.length > 0) {
          return triples[0];
        }
        
        // å°è¯•å‡ºå¯¹å­
        const pairs = findPairs(player.cards);
        if (pairs.length > 0) {
          return pairs[0];
        }
        
        // å‡ºæœ€å°çš„å•ç‰Œ
        const minCard = [...player.cards].sort((a, b) => a.value - b.value)[0];
        return [minCard];
      }
      
      // å¦åˆ™ï¼Œå°è¯•å‡ºæ¯”ä¸Šä¸€è½®å¤§çš„ç‰Œ
      const lastCardType = checkCardType(gameData.lastCards);
      
      // å°è¯•å‡ºåŒç±»å‹çš„ç‰Œ
      const possibleCards = findPossibleCards(player.cards, lastCardType, gameData.lastCards);
      
      if (possibleCards.length > 0) {
        // é€‰æ‹©åˆé€‚çš„ç‰Œ
        return possibleCards[0];
      }
      
      // å¦‚æœæœ‰ç‚¸å¼¹ï¼Œå‡ºç‚¸å¼¹
      const bombs = findBombs(player.cards);
      if (bombs.length > 0) {
        return bombs[0];
      }
      
      // ä¸å‡º
      return [];
    }
    
    // å›°éš¾AIå‡ºç‰Œç­–ç•¥
    function aiPlayHard(player) {
      // å¦‚æœä¸Šä¸€è½®æ²¡äººå‡ºç‰Œï¼Œå°è¯•å‡ºç»„åˆç‰Œ
      if (gameData.lastCards.length === 0) {
        // è®¡ç®—ç‰Œå‹å¾—åˆ†
        const scoreMap = {};
        
        // é¡ºå­
        const straights = findStraights(player.cards);
        straights.forEach(straight => {
          scoreMap[straight.map(c => c.value).join(',')] = straight.length * 2;
        });
        
        // è¿å¯¹
        const straightPairs = findStraightPairs(player.cards);
        straightPairs.forEach(pair => {
          scoreMap[pair.map(c => c.value).join(',')] = pair.length * 2.5;
        });
        
        // é£æœº
        const planes = findPlanes(player.cards);
        planes.forEach(plane => {
          scoreMap[plane.map(c => c.value).join(',')] = plane.length * 3;
        });
        
        // ä¸‰å¸¦
        const triples = findTriples(player.cards);
        triples.forEach(triple => {
          scoreMap[triple.map(c => c.value).join(',')] = triple.length * 2;
        });
        
        // å¯¹å­
        const pairs = findPairs(player.cards);
        pairs.forEach(pair => {
          scoreMap[pair.map(c => c.value).join(',')] = pair.length * 1.5;
        });
        
        // å•ç‰Œ
        player.cards.forEach(card => {
          // å¤§ç‰Œå¾—åˆ†ä½ï¼Œå°ç‰Œå¾—åˆ†é«˜
          const score = 20 - card.value;
          scoreMap[card.value] = score;
        });
        
        // æ‰¾åˆ°å¾—åˆ†æœ€é«˜çš„ç‰Œ
        let bestScore = 0;
        let bestCards = [];
        
        Object.keys(scoreMap).forEach(key => {
          if (scoreMap[key] > bestScore) {
            bestScore = scoreMap[key];
            if (key.includes(',')) {
              const values = key.split(',').map(v => parseInt(v));
              bestCards = player.cards.filter(c => values.includes(c.value));
            } else {
              const value = parseInt(key);
              bestCards = [player.cards.find(c => c.value === value)];
            }
          }
        });
        
        if (bestCards.length > 0) {
          return bestCards;
        }
      }
      
      // å¦åˆ™ï¼Œå°è¯•å‡ºæ¯”ä¸Šä¸€è½®å¤§çš„ç‰Œ
      const lastCardType = checkCardType(gameData.lastCards);
      
      // å°è¯•å‡ºåŒç±»å‹çš„ç‰Œ
      const possibleCards = findPossibleCards(player.cards, lastCardType, gameData.lastCards);
      
      if (possibleCards.length > 0) {
        // é€‰æ‹©åˆé€‚çš„ç‰Œ
        return possibleCards[0];
      }
      
      // å¦‚æœæœ‰ç‚¸å¼¹ï¼Œå‡ºç‚¸å¼¹
      const bombs = findBombs(player.cards);
      if (bombs.length > 0) {
        // å¦‚æœæ˜¯æœ€åä¸€è½®ï¼Œå‡ºæœ€å¤§çš„ç‚¸å¼¹
        if (player.cards.length <= 4) {
          return bombs[bombs.length - 1];
        }
        
        // å¦åˆ™ï¼Œå‡ºæœ€å°çš„ç‚¸å¼¹
        return bombs[0];
      }
      
      // ä¸å‡º
      return [];
    }
    
    // å‡ºç‰Œ
    function playCards(cards) {
      const currentPlayer = gameData.players[gameData.currentPlayer];
      
      // ä»ç©å®¶æ‰‹ä¸­ç§»é™¤ç‰Œ
      cards.forEach(card => {
        const index = currentPlayer.cards.findIndex(c => c.value === card.value && c.suit === card.suit);
        if (index !== -1) {
          currentPlayer.cards.splice(index, 1);
        }
      });
      
      // æ›´æ–°ä¸Šä¸€è½®å‡ºç‰Œ
      gameData.lastCards = [...cards];
      
      // æ£€æŸ¥æ˜¯å¦æ˜¯ç‚¸å¼¹
      const cardType = checkCardType(cards);
      if (cardType === gameData.cardTypes.BOMB || cardType === gameData.cardTypes.ROYAL_BOMB) {
        gameData.bombCount++;
        updateGameStatus(`${currentPlayer.name}å‡ºäº†ç‚¸å¼¹ï¼`);
      } else {
        updateGameStatus(`${currentPlayer.name}å‡ºäº†${cardType}`);
      }
      
      // æ›´æ–°UI
      renderPlayerCards();
      renderPlayArea(cards);
      
      // å¦‚æœä¸æ˜¯æ˜¥å¤©ï¼Œæ ‡è®°
      if (gameData.spring && gameData.lastCards.length > 0) {
        gameData.spring = false;
      }
    }
    
    // æ¸²æŸ“å‡ºç‰ŒåŒº
    function renderPlayArea(cards) {
      const playAreaEl = document.getElementById('playArea');
      playAreaEl.innerHTML = '';
      
      cards.forEach(card => {
        const cardEl = document.createElement('div');
        cardEl.className = 'card card-shadow mx-1 slide-up';
        
        // è®¾ç½®ç‰Œçš„æ ·å¼
        cardEl.style.backgroundColor = 'white';
        cardEl.style.border = '1px solid #ccc';
        cardEl.style.display = 'flex';
        cardEl.style.flexDirection = 'column';
        cardEl.style.justifyContent = 'space-between';
        cardEl.style.padding = '5px';
        
        // è®¾ç½®ç‰Œé¢å†…å®¹
        const textColor = card.color === 'red' ? 'text-red-600' : 'text-gray-900';
        cardEl.innerHTML = `
          <div class="${textColor} font-bold text-lg">
            ${card.face}${card.suit !== -1 ? card.suitSymbol : ''}
          </div>
          <div class="${textColor} font-bold text-2xl flex justify-center">
            ${card.suit !== -1 ? card.suitSymbol : card.face}
          </div>
          <div class="${textColor} font-bold text-lg flex justify-end">
            ${card.face}${card.suit !== -1 ? card.suitSymbol : ''}
          </div>
        `;
        
        playAreaEl.appendChild(cardEl);
      });
    }
    
    // æ¸…é™¤å‡ºç‰ŒåŒº
    function clearPlayArea() {
      const playAreaEl = document.getElementById('playArea');
      playAreaEl.innerHTML = '';
    }
    
    // æ¸…é™¤ç©å®¶çš„ç‰Œ
    function clearPlayerCards() {
      document.getElementById('playerCards').innerHTML = '';
      document.getElementById('ai1Cards').innerHTML = '';
      document.getElementById('ai2Cards').innerHTML = '';
      document.getElementById('landlordCards').innerHTML = '';
    }
    
    // æ˜¾ç¤ºå«åœ°ä¸»æŒ‰é’®
    function showBidButtons() {
      document.getElementById('bidButtons').classList.remove('hidden');
    }
    
    // éšè—å«åœ°ä¸»æŒ‰é’®
    function hideBidButtons() {
      document.getElementById('bidButtons').classList.add('hidden');
    }
    
    // æ˜¾ç¤ºå‡ºç‰ŒæŒ‰é’®
    function showPlayButtons() {
      document.getElementById('playButtons').classList.remove('hidden');
    }
    
    // éšè—å‡ºç‰ŒæŒ‰é’®
    function hidePlayButtons() {
      document.getElementById('playButtons').classList.add('hidden');
    }
    
    // åˆ‡æ¢ç‰Œçš„é€‰ä¸­çŠ¶æ€
    function toggleCardSelection(index) {
      const playerCardsEl = document.getElementById('playerCards');
      const cardEl = playerCardsEl.children[index];
      
      const selectedIndex = selectedCards.indexOf(index);
      if (selectedIndex === -1) {
        // é€‰ä¸­ç‰Œ
        selectedCards.push(index);
        cardEl.classList.add('card-selected');
      } else {
        // å–æ¶ˆé€‰ä¸­
        selectedCards.splice(selectedIndex, 1);
        cardEl.classList.remove('card-selected');
      }
    }
    
    // æ›´æ–°æ¸¸æˆçŠ¶æ€
    function updateGameStatus(message) {
      const gameStatusEl = document.getElementById('gameStatus');
      gameStatusEl.textContent = message;
      gameStatusEl.classList.remove('fade-in');
      void gameStatusEl.offsetWidth; // è§¦å‘é‡æ’
      gameStatusEl.classList.add('fade-in');
    }
    
    // ç»“æŸæ¸¸æˆ
    function endGame() {
      const currentPlayer = gameData.players[gameData.currentPlayer];
      
      updateGameStatus(`${currentPlayer.name}è·èƒœï¼`);
      
      // è®¡ç®—å¾—åˆ†
      let score = 1;
      
      // åŸºç¡€åˆ†
      score *= 2;
      
      // ç‚¸å¼¹å€æ•°
      score *= Math.pow(2, gameData.bombCount);
      
      // æ˜¥å¤©å€æ•°
      if (gameData.spring) {
        score *= 2;
      }
      
      // æ›´æ–°å¾—åˆ†
      if (currentPlayer.isLandlord) {
        // åœ°ä¸»è·èƒœ
        currentPlayer.score += score;
        gameData.players.forEach(player => {
          if (!player.isLandlord) {
            player.score -= score;
          }
        });
      } else {
        // å†œæ°‘è·èƒœ
        currentPlayer.score += score;
        gameData.players.forEach(player => {
          if (player.isLandlord) {
            player.score -= score * 2; // åœ°ä¸»è¾“ç»™ä¸¤ä¸ªå†œæ°‘
          } else if (player !== currentPlayer) {
            player.score += score;
          }
        });
      }
      
      // æ›´æ–°UI
      document.getElementById('playerScore').textContent = gameData.players[0].score;
      document.getElementById('ai1Score').textContent = gameData.players[1].score;
      document.getElementById('ai2Score').textContent = gameData.players[2].score;
      
      // è¯¢é—®æ˜¯å¦å¼€å§‹æ–°æ¸¸æˆ
      setTimeout(() => {
        if (confirm('æ¸¸æˆç»“æŸï¼Œæ˜¯å¦å¼€å§‹æ–°æ¸¸æˆï¼Ÿ')) {
          initGame();
        }
      }, 2000);
    }
    
    // æ£€æŸ¥ç‰Œå‹
    function checkCardType(cards) {
      if (cards.length === 0) {
        return null;
      }
      
      // å•ç‰Œ
      if (cards.length === 1) {
        return gameData.cardTypes.SINGLE;
      }
      
      // å¯¹å­
      if (cards.length === 2) {
        if (cards[0].value === cards[1].value) {
          return gameData.cardTypes.PAIR;
        }
        
        // ç‹ç‚¸
        if ((cards[0].value === 16 && cards[1].value === 17) || (cards[0].value === 17 && cards[1].value === 16)) {
          return gameData.cardTypes.ROYAL_BOMB;
        }
        
        return null;
      }
      
      // ä¸‰å¸¦
      if (cards.length === 3) {
        if (cards[0].value === cards[1].value && cards[1].value === cards[2].value) {
          return gameData.cardTypes.TRIPLE;
        }
        
        return null;
      }
      
      // ç‚¸å¼¹
      if (cards.length === 4) {
        if (cards[0].value === cards[1].value && cards[1].value === cards[2].value && cards[2].value === cards[3].value) {
          return gameData.cardTypes.BOMB;
        }
        
        return null;
      }
      
      // é¡ºå­
      if (isStraight(cards)) {
        return gameData.cardTypes.STRAIGHT;
      }
      
      // è¿å¯¹
      if (isStraightPair(cards)) {
        return gameData.cardTypes.STRAIGHT_PAIR;
      }
      
      // é£æœº
      if (isPlane(cards)) {
        return gameData.cardTypes.PLANE;
      }
      
      return null;
    }
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯é¡ºå­
    function isStraight(cards) {
      if (cards.length < 5) {
        return false;
      }
      
      // æ’åº
      const sortedCards = [...cards].sort((a, b) => a.value - b.value);
      
      // æ£€æŸ¥æ˜¯å¦æœ‰2æˆ–å¤§å°ç‹
      for (const card of sortedCards) {
        if (card.value >= 15) {
          return false;
        }
      }
      
      // æ£€æŸ¥æ˜¯å¦è¿ç»­
      for (let i = 1; i < sortedCards.length; i++) {
        if (sortedCards[i].value !== sortedCards[i - 1].value + 1) {
          return false;
        }
      }
      
      return true;
    }
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯è¿å¯¹
    function isStraightPair(cards) {
      if (cards.length < 6 || cards.length % 2 !== 0) {
        return false;
      }
      
      // æ’åº
      const sortedCards = [...cards].sort((a, b) => a.value - b.value);
      
      // æ£€æŸ¥æ˜¯å¦æœ‰2æˆ–å¤§å°ç‹
      for (const card of sortedCards) {
        if (card.value >= 15) {
          return false;
        }
      }
      
      // æ£€æŸ¥æ˜¯å¦æ˜¯å¯¹å­
      for (let i = 0; i < sortedCards.length; i += 2) {
        if (sortedCards[i].value !== sortedCards[i + 1].value) {
          return false;
        }
      }
      
      // æ£€æŸ¥æ˜¯å¦è¿ç»­
      for (let i = 2; i < sortedCards.length; i += 2) {
        if (sortedCards[i].value !== sortedCards[i - 2].value + 1) {
          return false;
        }
      }
      
      return true;
    }
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯é£æœº
    function isPlane(cards) {
      if (cards.length < 6 || cards.length % 3 !== 0) {
        return false;
      }
      
      // æ’åº
      const sortedCards = [...cards].sort((a, b) => a.value - b.value);
      
      // æ£€æŸ¥æ˜¯å¦æœ‰2æˆ–å¤§å°ç‹
      for (const card of sortedCards) {
        if (card.value >= 15) {
          return false;
        }
      }
      
      // æ£€æŸ¥æ˜¯å¦æ˜¯ä¸‰å¸¦
      for (let i = 0; i < sortedCards.length; i += 3) {
        if (sortedCards[i].value !== sortedCards[i + 1].value || sortedCards[i + 1].value !== sortedCards[i + 2].value) {
          return false;
        }
      }
      
      // æ£€æŸ¥æ˜¯å¦è¿ç»­
      for (let i = 3; i < sortedCards.length; i += 3) {
        if (sortedCards[i].value !== sortedCards[i - 3].value + 1) {
          return false;
        }
      }
      
      return true;
    }
    
    // æ£€æŸ¥æ˜¯å¦èƒ½å‡ºç‰Œ
    function canPlayCards(cards, cardType, lastCards, lastCardType) {
      // å¦‚æœä¸Šä¸€è½®æ²¡äººå‡ºç‰Œï¼Œå¯ä»¥å‡ºä»»ä½•ç‰Œ
      if (lastCards.length === 0) {
        return true;
      }
      
      // å¦‚æœç‰Œå‹ä¸åŒï¼Œåªèƒ½å‡ºç‚¸å¼¹æˆ–ç‹ç‚¸
      if (cardType !== lastCardType) {
        return cardType === gameData.cardTypes.BOMB || cardType === gameData.cardTypes.ROYAL_BOMB;
      }
      
      // æ ¹æ®ç‰Œå‹æ¯”è¾ƒå¤§å°
      switch (cardType) {
        case gameData.cardTypes.SINGLE:
          return cards[0].value > lastCards[0].value;
          
        case gameData.cardTypes.PAIR:
          return cards[0].value > lastCards[0].value;
          
        case gameData.cardTypes.TRIPLE:
          return cards[0].value > lastCards[0].value;
          
        case gameData.cardTypes.STRAIGHT:
          if (cards.length !== lastCards.length) {
            return false;
          }
          return cards[cards.length - 1].value > lastCards[lastCards.length - 1].value;
          
        case gameData.cardTypes.STRAIGHT_PAIR:
          if (cards.length !== lastCards.length) {
            return false;
          }
          return cards[cards.length - 1].value > lastCards[lastCards.length - 1].value;
          
        case gameData.cardTypes.PLANE:
          if (cards.length !== lastCards.length) {
            return false;
          }
          return cards[cards.length - 1].value > lastCards[lastCards.length - 1].value;
          
        case gameData.cardTypes.BOMB:
          // ç‚¸å¼¹æ¯”å¤§å°
          return cards[0].value > lastCards[0].value;
          
        case gameData.cardTypes.ROYAL_BOMB:
          // ç‹ç‚¸æœ€å¤§
          return true;
          
        default:
          return false;
      }
    }
    
    // è®¡ç®—ç‚¸å¼¹æ•°é‡
    function countBombs(cards) {
      const valueCount = {};
      cards.forEach(card => {
        valueCount[card.value] = (valueCount[card.value] || 0) + 1;
      });
      
      let bombCount = 0;
      Object.values(valueCount).forEach(count => {
        if (count >= 4) {
          bombCount++;
        }
      });
      
      // æ£€æŸ¥ç‹ç‚¸
      const hasSmallJoker = cards.some(card => card.value === 16);
      const hasBigJoker = cards.some(card => card.value === 17);
      if (hasSmallJoker && hasBigJoker) {
        bombCount++;
      }
      
      return bombCount;
    }
    
    // è®¡ç®—å¤§ç‰Œæ•°é‡
    function countHighCards(cards) {
      return cards.filter(card => card.value >= 13).length;
    }
    
    // è®¡ç®—é¡ºå­æ•°é‡
    function countStraights(cards) {
      return findStraights(cards).length;
    }
    
    // è®¡ç®—å¯¹å­æ•°é‡
    function countPairs(cards) {
      return findPairs(cards).length;
    }
    
    // æŸ¥æ‰¾é¡ºå­
    function findStraights(cards) {
      const straights = [];
      
      // æŒ‰ç‰Œå€¼åˆ†ç»„
      const valueMap = {};
      cards.forEach(card => {
        if (!valueMap[card.value]) {
          valueMap[card.value] = [];
        }
        valueMap[card.value].push(card);
      });
      
      // è·å–ç‰Œå€¼å¹¶æ’åº
      const values = Object.keys(valueMap).map(v => parseInt(v)).filter(v => v < 15).sort((a, b) => a - b);
      
      // æŸ¥æ‰¾é¡ºå­
      let currentStraight = [];
      for (let i = 0; i < values.length; i++) {
        if (i === 0 || values[i] === values[i - 1] + 1) {
          currentStraight.push(values[i]);
        } else {
          if (currentStraight.length >= 5) {
            // å°†é¡ºå­æ·»åŠ åˆ°ç»“æœä¸­
            const straightCards = [];
            currentStraight.forEach(value => {
              straightCards.push(valueMap[value][0]);
            });
            straights.push(straightCards);
          }
          currentStraight = [values[i]];
        }
      }
      
      // æ£€æŸ¥æœ€åä¸€ä¸ªé¡ºå­
      if (currentStraight.length >= 5) {
        const straightCards = [];
        currentStraight.forEach(value => {
          straightCards.push(valueMap[value][0]);
        });
        straights.push(straightCards);
      }
      
      return straights;
    }
    
    // æŸ¥æ‰¾è¿å¯¹
    function findStraightPairs(cards) {
      const straightPairs = [];
      
      // æŒ‰ç‰Œå€¼åˆ†ç»„
      const valueMap = {};
      cards.forEach(card => {
        if (!valueMap[card.value]) {
          valueMap[card.value] = [];
        }
        valueMap[card.value].push(card);
      });
      
      // è·å–æœ‰å¯¹å­çš„ç‰Œå€¼
      const pairValues = [];
      Object.keys(valueMap).forEach(value => {
        if (valueMap[value].length >= 2) {
          pairValues.push(parseInt(value));
        }
      });
      pairValues.sort((a, b) => a - b);
      
      // æŸ¥æ‰¾è¿å¯¹
      let currentStraightPair = [];
      for (let i = 0; i < pairValues.length; i++) {
        if (i === 0 || pairValues[i] === pairValues[i - 1] + 1) {
          currentStraightPair.push(pairValues[i]);
        } else {
          if (currentStraightPair.length >= 3) {
            // å°†è¿å¯¹æ·»åŠ åˆ°ç»“æœä¸­
            const straightPairCards = [];
            currentStraightPair.forEach(value => {
              straightPairCards.push(valueMap[value][0], valueMap[value][1]);
            });
            straightPairs.push(straightPairCards);
          }
          currentStraightPair = [pairValues[i]];
        }
      }
      
      // æ£€æŸ¥æœ€åä¸€ä¸ªè¿å¯¹
      if (currentStraightPair.length >= 3) {
        const straightPairCards = [];
        currentStraightPair.forEach(value => {
          straightPairCards.push(valueMap[value][0], valueMap[value][1]);
        });
        straightPairs.push(straightPairCards);
      }
      
      return straightPairs;
    }
    
    // æŸ¥æ‰¾é£æœº
    function findPlanes(cards) {
      const planes = [];
      
      // æŒ‰ç‰Œå€¼åˆ†ç»„
      const valueMap = {};
      cards.forEach(card => {
        if (!valueMap[card.value]) {
          valueMap[card.value] = [];
        }
        valueMap[card.value].push(card);
      });
      
      // è·å–æœ‰ä¸‰å¼ çš„ç‰Œå€¼
      const tripleValues = [];
      Object.keys(valueMap).forEach(value => {
        if (valueMap[value].length >= 3) {
          tripleValues.push(parseInt(value));
        }
      });
      tripleValues.sort((a, b) => a - b);
      
      // æŸ¥æ‰¾é£æœº
      let currentPlane = [];
      for (let i = 0; i < tripleValues.length; i++) {
        if (i === 0 || tripleValues[i] === tripleValues[i - 1] + 1) {
          currentPlane.push(tripleValues[i]);
        } else {
          if (currentPlane.length >= 2) {
            // å°†é£æœºæ·»åŠ åˆ°ç»“æœä¸­
            const planeCards = [];
            currentPlane.forEach(value => {
              planeCards.push(valueMap[value][0], valueMap[value][1], valueMap[value][2]);
            });
            planes.push(planeCards);
          }
          currentPlane = [tripleValues[i]];
        }
      }
      
      // æ£€æŸ¥æœ€åä¸€ä¸ªé£æœº
      if (currentPlane.length >= 2) {
        const planeCards = [];
        currentPlane.forEach(value => {
          planeCards.push(valueMap[value][0], valueMap[value][1], valueMap[value][2]);
        });
        planes.push(planeCards);
      }
      
      return planes;
    }
    
    // æŸ¥æ‰¾ä¸‰å¸¦
    function findTriples(cards) {
      const triples = [];
      
      // æŒ‰ç‰Œå€¼åˆ†ç»„
      const valueMap = {};
      cards.forEach(card => {
        if (!valueMap[card.value]) {
          valueMap[card.value] = [];
        }
        valueMap[card.value].push(card);
      });
      
      // æŸ¥æ‰¾ä¸‰å¼ 
      Object.keys(valueMap).forEach(value => {
        if (valueMap[value].length >= 3) {
          triples.push([valueMap[value][0], valueMap[value][1], valueMap[value][2]]);
        }
      });
      
      return triples;
    }
    
    // æŸ¥æ‰¾å¯¹å­
    function findPairs(cards) {
      const pairs = [];
      
      // æŒ‰ç‰Œå€¼åˆ†ç»„
      const valueMap = {};
      cards.forEach(card => {
        if (!valueMap[card.value]) {
          valueMap[card.value] = [];
        }
        valueMap[card.value].push(card);
      });
      
      // æŸ¥æ‰¾å¯¹å­
      Object.keys(valueMap).forEach(value => {
        if (valueMap[value].length >= 2) {
          pairs.push([valueMap[value][0], valueMap[value][1]]);
        }
      });
      
      return pairs;
    }
    
    // æŸ¥æ‰¾ç‚¸å¼¹
    function findBombs(cards) {
      const bombs = [];
      
      // æŒ‰ç‰Œå€¼åˆ†ç»„
      const valueMap = {};
      cards.forEach(card => {
        if (!valueMap[card.value]) {
          valueMap[card.value] = [];
        }
        valueMap[card.value].push(card);
      });
      
      // æŸ¥æ‰¾å››å¼ 
      Object.keys(valueMap).forEach(value => {
        if (valueMap[value].length >= 4) {
          bombs.push([valueMap[value][0], valueMap[value][1], valueMap[value][2], valueMap[value][3]]);
        }
      });
      
      // æ£€æŸ¥ç‹ç‚¸
      const hasSmallJoker = cards.some(card => card.value === 16);
      const hasBigJoker = cards.some(card => card.value === 17);
      if (hasSmallJoker && hasBigJoker) {
        const smallJoker = cards.find(card => card.value === 16);
        const bigJoker = cards.find(card => card.value === 17);
        bombs.push([smallJoker, bigJoker]);
      }
      
      return bombs;
    }
    
    // æŸ¥æ‰¾å¯å‡ºçš„ç‰Œ
    function findPossibleCards(cards, cardType, lastCards) {
      const possibleCards = [];
      
      switch (cardType) {
        case gameData.cardTypes.SINGLE:
          // æŸ¥æ‰¾æ¯”ä¸Šä¸€è½®å¤§çš„å•ç‰Œ
          cards.forEach(card => {
            if (card.value > lastCards[0].value) {
              possibleCards.push([card]);
            }
          });
          break;
          
        case gameData.cardTypes.PAIR:
          // æŸ¥æ‰¾æ¯”ä¸Šä¸€è½®å¤§çš„å¯¹å­
          const pairValue = lastCards[0].value;
          const pairMap = {};
          cards.forEach(card => {
            if (!pairMap[card.value]) {
              pairMap[card.value] = [];
            }
            pairMap[card.value].push(card);
          });
          
          Object.keys(pairMap).forEach(value => {
            if (parseInt(value) > pairValue && pairMap[value].length >= 2) {
              possibleCards.push([pairMap[value][0], pairMap[value][1]]);
            }
          });
          break;
          
        case gameData.cardTypes.TRIPLE:
          // æŸ¥æ‰¾æ¯”ä¸Šä¸€è½®å¤§çš„ä¸‰å¸¦
          const tripleValue = lastCards[0].value;
          const tripleMap = {};
          cards.forEach(card => {
            if (!tripleMap[card.value]) {
              tripleMap[card.value] = [];
            }
            tripleMap[card.value].push(card);
          });
          
          Object.keys(tripleMap).forEach(value => {
            if (parseInt(value) > tripleValue && tripleMap[value].length >= 3) {
              possibleCards.push([tripleMap[value][0], tripleMap[value][1], tripleMap[value][2]]);
            }
          });
          break;
          
        case gameData.cardTypes.STRAIGHT:
          // æŸ¥æ‰¾æ¯”ä¸Šä¸€è½®å¤§çš„é¡ºå­
          const straightLength = lastCards.length;
          const lastStraightMaxValue = Math.max(...lastCards.map(c => c.value));
          
          const straights = findStraights(cards);
          straights.forEach(straight => {
            if (straight.length === straightLength && Math.max(...straight.map(c => c.value)) > lastStraightMaxValue) {
              possibleCards.push(straight);
            }
          });
          break;
          
        case gameData.cardTypes.STRAIGHT_PAIR:
          // æŸ¥æ‰¾æ¯”ä¸Šä¸€è½®å¤§çš„è¿å¯¹
          const straightPairLength = lastCards.length;
          const lastStraightPairMaxValue = Math.max(...lastCards.map(c => c.value));
          
          const straightPairs = findStraightPairs(cards);
          straightPairs.forEach(straightPair => {
            if (straightPair.length === straightPairLength && Math.max(...straightPair.map(c => c.value)) > lastStraightPairMaxValue) {
              possibleCards.push(straightPair);
            }
          });
          break;
          
        case gameData.cardTypes.PLANE:
          // æŸ¥æ‰¾æ¯”ä¸Šä¸€è½®å¤§çš„é£æœº
          const planeLength = lastCards.length;
          const lastPlaneMaxValue = Math.max(...lastCards.map(c => c.value));
          
          const planes = findPlanes(cards);
          planes.forEach(plane => {
            if (plane.length === planeLength && Math.max(...plane.map(c => c.value)) > lastPlaneMaxValue) {
              possibleCards.push(plane);
            }
          });
          break;
          
        case gameData.cardTypes.BOMB:
          // æŸ¥æ‰¾æ¯”ä¸Šä¸€è½®å¤§çš„ç‚¸å¼¹
          const bombValue = lastCards[0].value;
          
          const bombs = findBombs(cards);
          bombs.forEach(bomb => {
            // ç‹ç‚¸å¯ä»¥ç‚¸ä»»ä½•ç‚¸å¼¹
            if (bomb[0].value === 16 && bomb[1].value === 17) {
              possibleCards.push(bomb);
            } else if (bomb[0].value > bombValue) {
              possibleCards.push(bomb);
            }
          });
          break;
          
        case gameData.cardTypes.ROYAL_BOMB:
          // ç‹ç‚¸æœ€å¤§ï¼Œæ— æ³•è¢«å…¶ä»–ç‰Œç‚¸
          break;
      }
      
      return possibleCards;
    }
    
    // äº‹ä»¶ç›‘å¬
    document.addEventListener('DOMContentLoaded', () => {
      // æ–°æ¸¸æˆæŒ‰é’®
      document.getElementById('newGame').addEventListener('click', () => {
        if (confirm('ç¡®å®šè¦å¼€å§‹æ–°æ¸¸æˆå—ï¼Ÿ')) {
          initGame();
        }
      });
      
      // éš¾åº¦é€‰æ‹©
      document.getElementById('difficulty').addEventListener('change', (e) => {
        gameData.difficulty = e.target.value;
      });
      
      // å«åœ°ä¸»æŒ‰é’®
      document.getElementById('bidLandlord').addEventListener('click', () => {
        playerBid(true);
      });
      
      // ä¸å«æŒ‰é’®
      document.getElementById('passBid').addEventListener('click', () => {
        playerBid(false);
      });
      
      // å‡ºç‰ŒæŒ‰é’®
      document.getElementById('playCards').addEventListener('click', () => {
        playerPlay(true);
      });
      
      // ä¸å‡ºæŒ‰é’®
      document.getElementById('passPlay').addEventListener('click', () => {
        playerPlay(false);
      });
      
      // åˆå§‹åŒ–æ¸¸æˆ
      initGame();
    });
  </script>
</body>
</html>